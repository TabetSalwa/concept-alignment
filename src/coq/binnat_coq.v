Require Import connectives_type.
Require Import leibniz_type.
Require Import logic_type.
Require Import relations_type.
Require Import bool_type.
Require Import nat_type.
Require Import connectives_coq.
Require Import leibniz_coq.
Require Import logic_coq.
Require Import relations_coq.
Require Import bool_coq.
Require Import BinNat.


Module Binnat_make (C : Connectives_Type) (L : Leibniz_Type) (G : Logic_Type C) (R : Relations_Type C G) (B : Bool_Type C L G R).
Import BinNums.
Import BinPosDef.
Import BinPos.
Require Import FunctionalExtensionality.
Require Import Coq.Program.Equality.
Definition nat := N.
Definition O := N0.
Definition S := N.succ.
Definition match_nat_prop : forall (return_:(nat -> Prop)), (return_ O) -> (forall (n:nat), return_ (S n)) -> forall (z:nat), return_ z := fun (return_ : nat -> Prop) => fun (HO : return_ O) => fun (HS : forall n : nat, return_ (S n)) (z : nat) => match z as n return (return_ n) with N0 => HO | N.pos p => eq_ind (S (Pos.pred_N p)) return_ (HS (Pos.pred_N p)) (N.pos p) (N.succ_pos_pred p) end.
Definition match_nat_type : forall (return_:Type), return_ -> (nat -> return_) -> nat -> return_ := fun (return_:Type) => fun (case_O:return_) => fun (case_S : nat -> return_) => fun (n : nat) => match n with N0 => case_O | N.pos p => case_S (Pos.pred_N p) end.
Definition axiom_match_nat_type_O : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), C.equal (return_type) (match_nat_type (return_type) case_O case_S O) case_O := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S : nat -> return_type) => @C.equal_refl return_type case_O.
Definition eq_match_nat_type_O : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), L.leibniz (return_type) (match_nat_type (return_type) case_O case_S O) case_O := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:nat -> return_type) => ((((C.equal_leibniz) (return_type)) (match_nat_type (return_type) case_O case_S O)) (case_O)) ((((axiom_match_nat_type_O) (return_type)) (case_O)) (case_S)).
Definition sym_eq_match_nat_type_O : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), L.leibniz (return_type) case_O (match_nat_type (return_type) case_O case_S O) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:nat -> return_type) => ((((L.sym_leibniz) (return_type)) (match_nat_type (return_type) case_O case_S O)) (case_O)) ((((eq_match_nat_type_O) (return_type)) (case_O)) (case_S)).
Definition pred_succ : forall (n:nat), Pos.pred_N (N.succ_pos n) = n := N.pos_pred_succ.
Definition axiom_match_nat_type_S : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), forall (n:nat), C.equal (return_type) (match_nat_type (return_type) case_O case_S (S n)) (case_S n) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S : nat -> return_type) => fun (n:nat) => eq_ind (case_S n) (fun (x:return_type) => C.equal return_type x (case_S n)) (C.equal_refl return_type (case_S n)) (match S n with N0 => case_O | N.pos p => case_S (Pos.pred_N p) end) (@eq_trans return_type (case_S n) (case_S (Pos.pred_N (N.succ_pos n))) (match S n with N0 => case_O | N.pos p => case_S (Pos.pred_N p) end) (@f_equal nat return_type case_S n (Pos.pred_N (N.succ_pos n)) (@eq_sym nat (Pos.pred_N (N.succ_pos n)) n (N.pos_pred_succ n))) (@f_equal nat return_type (fun (z:nat) => match z with N0 => case_O | N.pos p => case_S (Pos.pred_N p) end) (N.pos (N.succ_pos n)) (S n) (N.succ_pos_spec n))).
Definition eq_match_nat_type_S : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), forall (n:nat), L.leibniz (return_type) (match_nat_type (return_type) case_O case_S (S n)) (case_S n) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:nat -> return_type) => fun (n:nat) => ((((C.equal_leibniz) (return_type)) (match_nat_type (return_type) case_O case_S (S n))) (case_S n)) (((((axiom_match_nat_type_S) (return_type)) (case_O)) (case_S)) (n)).
Definition sym_eq_match_nat_type_S : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), forall (n:nat), L.leibniz (return_type) (case_S n) (match_nat_type (return_type) case_O case_S (S n)) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:nat -> return_type) => fun (n:nat) => ((((L.sym_leibniz) (return_type)) (match_nat_type (return_type) case_O case_S (S n))) (case_S n)) (((((eq_match_nat_type_S) (return_type)) (case_O)) (case_S)) (n)).
Definition filter_nat_type : forall (return_:Type), (nat -> return_) -> nat -> return_ := fun (return_type:Type) => fun (return_ : nat -> return_type) => fun (n : nat) => return_ n.
Definition axiom_filter_nat_type_O : forall return_type, forall (return_:(nat -> return_type)), C.equal (return_type) (filter_nat_type (return_type) return_ O) (return_ O) := fun (return_type:Type) => fun (return_ : nat -> return_type) => C.equal_refl return_type (return_ O).
Definition eq_filter_nat_type_O : forall return_type, forall (return_:(nat -> return_type)), L.leibniz (return_type) (filter_nat_type (return_type) return_ O) (return_ O) := fun (return_type:Type) => fun (return_:nat -> return_type) => ((((C.equal_leibniz) (return_type)) (filter_nat_type (return_type) return_ O)) (return_ O)) (((axiom_filter_nat_type_O) (return_type)) (return_)).
Definition sym_eq_filter_nat_type_O : forall return_type, forall (return_:(nat -> return_type)), L.leibniz (return_type) (return_ O) (filter_nat_type (return_type) return_ O) := fun (return_type:Type) => fun (return_:nat -> return_type) => ((((L.sym_leibniz) (return_type)) (filter_nat_type (return_type) return_ O)) (return_ O)) (((eq_filter_nat_type_O) (return_type)) (return_)).
Definition axiom_filter_nat_type_S : forall return_type, forall (return_:(nat -> return_type)), forall (n:nat), C.equal (return_type) (filter_nat_type (return_type) return_ (S n)) (return_ (S n)) := fun (return_type:Type) => fun (return_ : nat -> return_type) => fun (n:nat) => C.equal_refl return_type (return_ (S n)).
Definition eq_filter_nat_type_S : forall return_type, forall (return_:(nat -> return_type)), forall (n:nat), L.leibniz (return_type) (filter_nat_type (return_type) return_ (S n)) (return_ (S n)) := fun (return_type:Type) => fun (return_:nat -> return_type) => fun (n:nat) => ((((C.equal_leibniz) (return_type)) (filter_nat_type (return_type) return_ (S n))) (return_ (S n))) ((((axiom_filter_nat_type_S) (return_type)) (return_)) (n)).
Definition sym_eq_filter_nat_type_S : forall return_type, forall (return_:(nat -> return_type)), forall (n:nat), L.leibniz (return_type) (return_ (S n)) (filter_nat_type (return_type) return_ (S n)) := fun (return_type:Type) => fun (return_:nat -> return_type) => fun (n:nat) => ((((L.sym_leibniz) (return_type)) (filter_nat_type (return_type) return_ (S n))) (return_ (S n))) ((((eq_filter_nat_type_S) (return_type)) (return_)) (n)).
Definition nat_ind : forall (Q:(nat -> Prop)), (Q O) -> (forall (x:nat), (Q x) -> Q (S x)) -> forall (x:nat), Q x := N.peano_ind.
Definition pred : nat -> nat := fun (n:nat) => match_nat_type (nat) O (fun (p:nat) => p) n.
Definition not_zero : nat -> Prop := fun (n:nat) => match_nat_type (Prop) C.False (fun (p:nat) => C.True) n.
Definition le : nat -> nat -> Prop := N.le.
Definition le_n : forall (n:nat), le n n := N.le_refl.
Definition le_S : forall (n:nat), forall (m:nat), (le n m) -> le n (S m) := N.le_le_succ_r.
Definition le_ind : forall (n:nat), forall (Q:(nat -> Prop)), (Q n) -> (forall (m:nat), (le n m) -> (Q m) -> Q (S m)) -> forall (m:nat), (le n m) -> Q m := fun (n : N) => fun (Q : N -> Prop) => fun (Hinit : Q n) => fun (Hsucc : forall m : N, (match n with N0 => match m with N0 => Eq | N.pos _ => Lt end | N.pos n' => match m with N0 => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x with (p~1)%positive => match y with (q~1)%positive => compare_cont r p q | (q~0)%positive => compare_cont Gt p q | 1%positive => Gt end | (p~0)%positive => match y with (q~1)%positive => compare_cont Lt p q | (q~0)%positive => compare_cont r p q | 1%positive => Gt end | 1%positive => match y with 1%positive => r | _ => Lt end end) Eq n' m' end end = Gt -> False) -> Q m -> Q match m with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end) (m : N) => nat_ind (fun m0 : N => (match n with N0 => match m0 with N0 => Eq | N.pos _ => Lt end | N.pos n' => match m0 with N0 => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x with | (p~1)%positive => match y with (q~1)%positive => compare_cont r p q | (q~0)%positive => compare_cont Gt p q | 1%positive => Gt end | (p~0)%positive => match y with (q~1)%positive => compare_cont Lt p q | (q~0)%positive => compare_cont r p q | 1%positive => Gt end | 1%positive => match y with 1%positive => r | _ => Lt end end) Eq n' m' end end = Gt -> False) -> Q m0) (match n as n0 return (Q n0 -> (match n0 with N0 => Eq | N.pos _ => Gt end = Gt -> False) -> Q N0) with | N0 => fun (Hinit0 : Q N0) (_ : Eq = Gt -> False) => Hinit0 | N.pos p => fun (_ : Q (N.pos p)) (Hle : Gt = Gt -> False) => match Hle eq_refl return (Q N0) with end end Hinit) (fun (z : N) (Hz : (match n with N0 => match z with N0 => Eq | N.pos _ => Lt end | N.pos n' => match z with N0 => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x with (p~1)%positive => match y with (q~1)%positive => compare_cont r p q | (q~0)%positive => compare_cont Gt p q | 1%positive => Gt end | (p~0)%positive => match y with (q~1)%positive => compare_cont Lt p q | (q~0)%positive => compare_cont r p q | 1%positive => Gt end | 1%positive => match y with 1%positive => r | _ => Lt end end) Eq n' m' end end = Gt -> False) -> Q z) (Hle : match n with N0 => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Eq | N.pos _ => Lt end | N.pos n' => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x with (p~1)%positive => match y with (q~1)%positive => compare_cont r p q | (q~0)%positive => compare_cont Gt p q | 1%positive => Gt end | (p~0)%positive => match y with (q~1)%positive => compare_cont Lt p q | (q~0)%positive => compare_cont r p q | 1%positive => Gt end | 1%positive => match y with 1%positive => r | _ => Lt end end) Eq n' m' end end = Gt -> False) => match match n with N0 => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Eq | N.pos _ => Lt end | N.pos n' => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x with (p~1)%positive => match y with (q~1)%positive => compare_cont r p q | (q~0)%positive => compare_cont Gt p q | 1%positive => Gt end | (p~0)%positive => match y with (q~1)%positive => compare_cont Lt p q | (q~0)%positive => compare_cont r p q | 1%positive => Gt end | 1%positive => match y with 1%positive => r | _ => Lt end end) Eq n' m' end end as c return (match n with N0 => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Eq | N.pos _ => Lt end | N.pos n' => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with | (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x with (p~1)%positive => match y with (q~1)%positive => compare_cont r p q | (q~0)%positive => compare_cont Gt p q | 1%positive => Gt end | (p~0)%positive => match y with (q~1)%positive => compare_cont Lt p q | (q~0)%positive => compare_cont r p q | 1%positive => Gt end | 1%positive => match y with | 1%positive => r | _ => Lt end end) Eq n' m' end end = c -> Q match z with | N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with | (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end) with Eq => fun Hcomp : match n with N0 => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Eq | N.pos _ => Lt end | N.pos n' => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x with (p~1)%positive => match y with (q~1)%positive => compare_cont r p q | (q~0)%positive => compare_cont Gt p q | 1%positive => Gt end | (p~0)%positive => match y with (q~1)%positive => compare_cont Lt p q | (q~0)%positive => compare_cont r p q | 1%positive => Gt end | 1%positive => match y with 1%positive => r | _ => Lt end end) Eq n' m' end end = Eq => match N.compare_eq n match z with N0 => 1 | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end Hcomp in (_ = a) return (Q a) with eq_refl => Hinit end | Lt => fun Hcomp : match n with N0 => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with | (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with | N0 => Eq | N.pos _ => Lt end | N.pos n' => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x with (p~1)%positive =>  match y with (q~1)%positive => compare_cont r p q | (q~0)%positive => compare_cont Gt p q | 1%positive => Gt end | (p~0)%positive => match y with (q~1)%positive => compare_cont Lt p q | (q~0)%positive => compare_cont r p q | 1%positive => Gt end | 1%positive => match y with | 1%positive => r | _ => Lt end end) Eq n' m' end end = Lt => Hsucc z (match N.lt_succ_r n z with | conj x _ => x end Hcomp) (Hz (match N.lt_succ_r n z with | conj x _ => x end Hcomp)) | Gt => fun Hcomp : match n with | N0 => match match z with | N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with | (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Eq | N.pos _ => Lt end | N.pos n' => match match z with N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with N0 => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x with (p~1)%positive => match y with | (q~1)%positive => compare_cont r p q | (q~0)%positive => compare_cont Gt p q | 1%positive => Gt end | (p~0)%positive => match y with (q~1)%positive => compare_cont Lt p q | (q~0)%positive => compare_cont r p q | 1%positive => Gt end | 1%positive => match y with 1%positive => r | _ => Lt end end) Eq n' m' end end = Gt => match match N.le_ngt n match z with N0 => 1 | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with conj x _ => x end Hle (match N.gt_lt_iff n match z with | N0 => 1 | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with | (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with | conj x _ => x end Hcomp) return (Q match z with | N0 => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end) with end end eq_refl) m.
Definition lt : nat -> nat -> Prop := fun (n:nat) => fun (m:nat) => le (S n) m.
Definition plus : nat -> nat -> nat := N.add.
Definition plus_body : nat -> nat -> nat := N.add.
Definition axiom_plus : forall (n:nat), C.equal (nat -> nat) (plus n) (filter_nat_type (nat -> nat) plus_body n) := fun (n : nat) => C.equal_refl (nat -> nat) (plus n).
Definition eq_plus : forall (n:nat), L.leibniz (nat -> nat) (plus n) (filter_nat_type (nat -> nat) plus_body n) := fun (n:nat) => ((((C.equal_leibniz) (nat -> nat)) (plus n)) (filter_nat_type (nat -> nat) plus_body n)) ((axiom_plus) (n)).
Definition sym_eq_plus : forall (n:nat), L.leibniz (nat -> nat) (filter_nat_type (nat -> nat) plus_body n) (plus n) := fun (n:nat) => ((((L.sym_leibniz) (nat -> nat)) (plus n)) (filter_nat_type (nat -> nat) plus_body n)) ((eq_plus) (n)).
Definition axiom_plus_body_O : C.equal (nat -> nat) (plus_body O) (fun (m:nat) => m) := C.equal_refl (nat -> nat) (fun (m:nat) => m).
Definition eq_plus_body_O : L.leibniz (nat -> nat) (plus_body O) (fun (m:nat) => m) := ((((C.equal_leibniz) (nat -> nat)) (plus_body O)) (fun (m:nat) => m)) (axiom_plus_body_O).
Definition sym_eq_plus_body_O : L.leibniz (nat -> nat) (fun (m:nat) => m) (plus_body O) := ((((L.sym_leibniz) (nat -> nat)) (plus_body O)) (fun (m:nat) => m)) (eq_plus_body_O).
Definition axiom_plus_body_S : forall (n:nat), C.equal (nat -> nat) (plus_body (S n)) (fun (m:nat) => S (plus n m)) := fun (n:nat) => eq_ind (plus_body (S n)) (fun (f : nat -> nat) => C.equal (nat -> nat) (plus_body (S n)) f) (C.equal_refl (nat -> nat) (plus_body (S n))) (fun (m:nat) => S (plus n m)) (functional_extensionality (plus_body (S n)) (fun (m:nat) => S (plus n m)) (fun (m:nat) => N.add_succ_l n m)).
Definition eq_plus_body_S : forall (n:nat), L.leibniz (nat -> nat) (plus_body (S n)) (fun (m:nat) => S (plus n m)) := fun (n:nat) => ((((C.equal_leibniz) (nat -> nat)) (plus_body (S n))) (fun (m:nat) => S (plus n m))) ((axiom_plus_body_S) (n)).
Definition sym_eq_plus_body_S : forall (n:nat), L.leibniz (nat -> nat) (fun (m:nat) => S (plus n m)) (plus_body (S n)) := fun (n:nat) => ((((L.sym_leibniz) (nat -> nat)) (plus_body (S n))) (fun (m:nat) => S (plus n m))) ((eq_plus_body_S) (n)).
Definition nat_case : forall (n:nat), forall (P:(nat -> Prop)), ((G.eq (nat) n O) -> P O) -> (forall (m:nat), (G.eq (nat) n (S m)) -> P (S m)) -> P n := fun (n:nat) => fun (P:nat -> Prop) => ((((nat_ind) (fun (_x_365:nat) => ((G.eq (nat) _x_365 O) -> P O) -> (forall (m:nat), (G.eq (nat) _x_365 (S m)) -> P (S m)) -> P _x_365)) (fun (auto:(G.eq (nat) O O) -> P O) => (fun (auto':forall (m:nat), (G.eq (nat) O (S m)) -> P (S m)) => ((auto) (((G.refl) (nat)) (O)))))) (fun (x_366:nat) => fun (_x_368:((G.eq (nat) x_366 O) -> P O) -> (forall (m:nat), (G.eq (nat) x_366 (S m)) -> P (S m)) -> P x_366) => (fun (auto:(G.eq (nat) (S x_366) O) -> P O) => (fun (auto':forall (m:nat), (G.eq (nat) (S x_366) (S m)) -> P (S m)) => (((auto') (x_366)) (((G.refl) (nat)) (S x_366))))))) (n).
Definition nat_elim2 : forall (R:(nat -> nat -> Prop)), (forall (n:nat), R O n) -> (forall (n:nat), R (S n) O) -> (forall (n:nat), forall (m:nat), (R n m) -> R (S n) (S m)) -> forall (n:nat), forall (m:nat), R n m := fun (R:nat -> nat -> Prop) => fun (ROn:forall (n:nat), R O n) => (fun (RSO:forall (n:nat), R (S n) O) => (fun (RSS:forall (n:nat), forall (m:nat), (R n m) -> R (S n) (S m)) => (fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => forall (m:nat), R _x_365 m)) (fun (m:nat) => (ROn) (m))) (fun (n0:nat) => fun (Rn0m:forall (m:nat), R n0 m) => (fun (m:nat) => ((((match_nat_prop) (fun (__:nat) => R (S n0) __)) ((RSO) (n0))) (fun (auto:nat) => (((RSS) (n0)) (auto)) ((Rn0m) (auto)))) (m)))) (n)))).
Definition pred_Sn : forall (n:nat), G.eq (nat) n (pred (S n)) := fun (n:nat) => ((((((sym_eq_match_nat_type_S) (nat)) (O)) (fun (p:nat) => p)) (n)) (fun (y:nat) => G.eq (nat) n y)) (((G.refl) (nat)) (n)).
Definition injective_S : R.injective (nat) (nat) S := fun (x:nat) => fun (y:nat) => fun (auto:G.eq (nat) (S x) (S y)) => (((((((G.rewrite_l) (nat)) (y)) (fun (__:nat) => G.eq (nat) __ y)) (((G.refl) (nat)) (y))) (x)) (((((((G.rewrite_r) (nat)) (pred (S x))) (fun (__:nat) => G.eq (nat) y __)) (((((((G.rewrite_r) (nat)) (S y)) (fun (__:nat) => G.eq (nat) y (pred __))) ((pred_Sn) (y))) (S x)) (auto))) (x)) ((pred_Sn) (x)))).
Definition plus_O_n : forall (n:nat), G.eq (nat) n (plus O n) := fun (n:nat) => (((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => G.eq (nat) n (y n))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => G.eq (nat) n (y n))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => G.eq (nat) n (y n))) (((G.refl) (nat)) (n)))).
Definition plus_n_O : forall (n:nat), G.eq (nat) n (plus n O) := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => G.eq (nat) _x_365 (plus _x_365 O))) ((((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => G.eq (nat) O (y O))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => G.eq (nat) O (y O))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => G.eq (nat) O (y O))) (((G.refl) (nat)) (O)))))) (fun (x_366:nat) => fun (_x_368:G.eq (nat) x_366 (plus x_366 O)) => ((((sym_eq_plus) (S x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S x_366) (y O))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S x_366) (y O))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S x_366) (y O))) (((((((G.rewrite_l) (nat)) (x_366)) (fun (__:nat) => G.eq (nat) (S x_366) (S __))) (((G.refl) (nat)) (S x_366))) (plus x_366 O)) (_x_368))))))) (n).
Definition plus_n_Sm : forall (n:nat), forall (m:nat), G.eq (nat) (S (plus n m)) (plus n (S m)) := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => forall (m:nat), G.eq (nat) (S (plus _x_365 m)) (plus _x_365 (S m)))) (fun (m:nat) => (((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus O (S m)))) ((((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => G.eq (nat) (S (filter_nat_type (nat -> nat) plus_body O m)) (y (S m)))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => G.eq (nat) (S (filter_nat_type (nat -> nat) plus_body O m)) (y (S m)))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus_body O (S m)))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus_body O (S m)))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => G.eq (nat) (S m) (y (S m)))) (((G.refl) (nat)) (S m))))))))) (fun (x_366:nat) => fun (_x_368:forall (m:nat), G.eq (nat) (S (plus x_366 m)) (plus x_366 (S m))) => (fun (m:nat) => (((sym_eq_plus) (S x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus (S x_366) (S m)))) ((((sym_eq_plus) (S x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (filter_nat_type (nat -> nat) plus_body (S x_366) m)) (y (S m)))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (filter_nat_type (nat -> nat) plus_body (S x_366) m)) (y (S m)))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus_body (S x_366) (S m)))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus_body (S x_366) (S m)))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (S (plus x_366 m))) (y (S m)))) (((((((G.rewrite_r) (nat)) (plus x_366 (S m))) (fun (__:nat) => G.eq (nat) (S __) (S (plus x_366 (S m))))) (((((((G.rewrite_r) (nat)) (plus x_366 (S (S m)))) (fun (__:nat) => G.eq (nat) __ (S (plus x_366 (S m))))) (((((((G.rewrite_r) (nat)) (plus x_366 (S (S m)))) (fun (__:nat) => G.eq (nat) (plus x_366 (S (S m))) __)) (((G.refl) (nat)) (plus x_366 (S (S m))))) (S (plus x_366 (S m)))) ((_x_368) (S m)))) (S (plus x_366 (S m)))) ((_x_368) (S m)))) (S (plus x_366 m))) ((_x_368) (m))))))))))) (n).
Definition commutative_plus : R.commutative (nat) plus := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => forall (y:nat), G.eq (nat) (plus _x_365 y) (plus y _x_365))) (fun (y:nat) => (((sym_eq_plus) (O)) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y O))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y O))) (((sym_eq_plus_body_O) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y O))) (((((((G.rewrite_l) (nat)) (y)) (fun (__:nat) => G.eq (nat) y __)) (((G.refl) (nat)) (y))) (plus y O)) ((plus_n_O) (y))))))) (fun (x_366:nat) => fun (_x_368:forall (y:nat), G.eq (nat) (plus x_366 y) (plus y x_366)) => (fun (y:nat) => (((sym_eq_plus) (S x_366)) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y (S x_366)))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y (S x_366)))) ((((sym_eq_plus_body_S) (x_366)) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y (S x_366)))) (((((((G.rewrite_r) (nat)) (plus x_366 (S y))) (fun (__:nat) => G.eq (nat) __ (plus y (S x_366)))) (((((((G.rewrite_r) (nat)) (plus y (S x_366))) (fun (__:nat) => G.eq (nat) __ (plus y (S x_366)))) (((G.refl) (nat)) (plus y (S x_366)))) (plus x_366 (S y))) (((((((G.rewrite_l) (nat)) (S (plus x_366 y))) (fun (__:nat) => G.eq (nat) __ (plus y (S x_366)))) (((((((G.rewrite_r) (nat)) (plus y x_366)) (fun (__:nat) => G.eq (nat) (S __) (plus y (S x_366)))) (((plus_n_Sm) (y)) (x_366))) (plus x_366 y)) ((_x_368) (y)))) (plus x_366 (S y))) (((plus_n_Sm) (x_366)) (y))))) (S (plus x_366 y))) (((plus_n_Sm) (x_366)) (y)))))))) (n).
Definition associative_plus : R.associative (nat) plus := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => forall (y:nat), forall (z:nat), G.eq (nat) (plus (plus _x_365 y) z) (plus _x_365 (plus y z)))) (fun (y:nat) => fun (z:nat) => (((sym_eq_plus) (O)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus O y) z) (x (plus y z)))) ((((sym_eq_plus) (O)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (filter_nat_type (nat -> nat) plus_body O (plus y z)))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (filter_nat_type (nat -> nat) plus_body O (plus y z)))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus_body O y) z) (x (plus y z)))) (((sym_eq_plus_body_O) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus_body O y) z) (x (plus y z)))) (((sym_eq_plus_body_O) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (plus y z))) (((G.refl) (nat)) (plus y z))))))))) (fun (x_366:nat) => fun (_x_368:forall (y:nat), forall (z:nat), G.eq (nat) (plus (plus x_366 y) z) (plus x_366 (plus y z))) => (fun (y:nat) => fun (z:nat) => (((sym_eq_plus) (S x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus (S x_366) y) z) (x (plus y z)))) ((((sym_eq_plus) (S x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (filter_nat_type (nat -> nat) plus_body (S x_366) (plus y z)))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (filter_nat_type (nat -> nat) plus_body (S x_366) (plus y z)))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus_body (S x_366) y) z) (x (plus y z)))) ((((sym_eq_plus_body_S) (x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus_body (S x_366) y) z) (x (plus y z)))) ((((sym_eq_plus_body_S) (x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (S (plus x_366 (plus y z))))) ((((sym_eq_plus) (S (plus x_366 y))) (fun (x:(nat -> nat)) => G.eq (nat) (x z) (S (plus x_366 (plus y z))))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (plus x_366 y)) (fun (x:(nat -> nat)) => G.eq (nat) (x z) (S (plus x_366 (plus y z))))) ((((sym_eq_plus_body_S) (plus x_366 y)) (fun (x:(nat -> nat)) => G.eq (nat) (x z) (S (plus x_366 (plus y z))))) (((((((G.rewrite_r) (nat)) (plus x_366 (plus y z))) (fun (__:nat) => G.eq (nat) (S __) (S (plus x_366 (plus y z))))) (((G.refl) (nat)) (S (plus x_366 (plus y z))))) (plus (plus x_366 y) z)) (((_x_368) (y)) (z)))))))))))))) (n).
Definition assoc_plus1 : forall (a:nat), forall (b:nat), forall (c:nat), G.eq (nat) (plus c (plus b a)) (plus (plus b c) a) := fun (a:nat) => fun (b:nat) => fun (c:nat) => ((((((G.rewrite_r) (nat)) (plus a b)) (fun (__:nat) => G.eq (nat) (plus c __) (plus (plus b c) a))) (((((((G.rewrite_r) (nat)) (plus a (plus b c))) (fun (__:nat) => G.eq (nat) (plus c (plus a b)) __)) (((((((G.rewrite_r) (nat)) (plus a (plus b c))) (fun (__:nat) => G.eq (nat) __ (plus a (plus b c)))) (((G.refl) (nat)) (plus a (plus b c)))) (plus c (plus a b))) (((((((G.rewrite_l) (nat)) (plus (plus a b) c)) (fun (__:nat) => G.eq (nat) (plus c (plus a b)) __)) (((commutative_plus) (c)) (plus a b))) (plus a (plus b c))) ((((associative_plus) (a)) (b)) (c))))) (plus (plus b c) a)) (((commutative_plus) (plus b c)) (a)))) (plus b a)) (((commutative_plus) (b)) (a)).
Definition injective_plus_r : forall (n:nat), R.injective (nat) (nat) (fun (m:nat) => plus n m) := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => R.injective (nat) (nat) (fun (m:nat) => plus _x_365 m))) ((((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) (fun (x:nat) => fun (y:nat) => fun (auto:G.eq (nat) x y) => (((((((G.rewrite_l) (nat)) (x)) (fun (__:nat) => G.eq (nat) x __)) (((G.refl) (nat)) (x))) (y)) (auto))))))) (fun (x_366:nat) => fun (_x_368:forall (x:nat), forall (y:nat), (G.eq (nat) (plus x_366 x) (plus x_366 y)) -> G.eq (nat) x y) => ((((sym_eq_plus) (S x_366)) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) (fun (x:nat) => fun (y:nat) => fun (auto:G.eq (nat) (S (plus x_366 x)) (S (plus x_366 y))) => ((((_x_368) (x)) (y)) ((((injective_S) (plus x_366 x)) (plus x_366 y)) (((((((G.rewrite_r) (nat)) (plus x_366 (S x))) (fun (__:nat) => G.eq (nat) __ (S (plus x_366 y)))) (((((((G.rewrite_r) (nat)) (plus x_366 (S y))) (fun (__:nat) => G.eq (nat) (plus x_366 (S x)) __)) (((((((G.rewrite_l) (nat)) (plus x_366 (S x))) (fun (__:nat) => G.eq (nat) (plus x_366 (S x)) __)) (((G.refl) (nat)) (plus x_366 (S x)))) (plus x_366 (S y))) (((((((G.rewrite_l) (nat)) (S (plus x_366 y))) (fun (__:nat) => G.eq (nat) (plus x_366 (S x)) __)) (((((((G.rewrite_l) (nat)) (S (plus x_366 x))) (fun (__:nat) => G.eq (nat) __ (S (plus x_366 y)))) (auto)) (plus x_366 (S x))) (((plus_n_Sm) (x_366)) (x)))) (plus x_366 (S y))) (((plus_n_Sm) (x_366)) (y))))) (S (plus x_366 y))) (((plus_n_Sm) (x_366)) (y)))) (S (plus x_366 x))) (((plus_n_Sm) (x_366)) (x))))))))))) (n).
Definition not_eq_S : forall (n:nat), forall (m:nat), (C.Not (G.eq (nat) n m)) -> C.Not (G.eq (nat) (S n) (S m)) := fun (n:nat) => fun (m:nat) => fun (auto:C.Not (G.eq (nat) n m)) => (((((G.not_to_not) (G.eq (nat) (S n) (S m))) (G.eq (nat) n m)) (fun (auto':G.eq (nat) (S n) (S m)) => (((((((G.rewrite_l) (nat)) (m)) (fun (__:nat) => G.eq (nat) __ m)) (((G.refl) (nat)) (m))) (n)) (((((((G.rewrite_r) (nat)) (pred (S n))) (fun (__:nat) => G.eq (nat) m __)) (((((((G.rewrite_r) (nat)) (S m)) (fun (__:nat) => G.eq (nat) m (pred __))) ((pred_Sn) (m))) (S n)) (auto'))) (n)) ((pred_Sn) (n)))))) (auto)).
Definition not_eq_O_S : forall (n:nat), C.Not (G.eq (nat) O (S n)) := fun (n:nat) => ((C.nmk) (G.eq (nat) O (S n))) (fun (eqOS:G.eq (nat) O (S n)) => ((((((eq_match_nat_type_O) (Prop)) (C.False)) (fun (p:nat) => C.True)) (fun (y:Prop) => y)) (((((((G.eq_ind_r) (nat)) (S n)) (fun (x:nat) => not_zero x)) (((((((sym_eq_match_nat_type_S) (Prop)) (C.False)) (fun (p:nat) => C.True)) (n)) (fun (y:Prop) => y)) (C.I))) (O)) (eqOS)))).
Definition lt_to_not_zero : forall (n:nat), forall (m:nat), (lt n m) -> not_zero m := fun (n:nat) => fun (m:nat) => fun (Hlt:lt n m) => (((((((le_ind) (S n)) (fun (x_417:nat) => not_zero x_417)) (((((((sym_eq_match_nat_type_S) (Prop)) (C.False)) (fun (p:nat) => C.True)) (n)) (fun (y:Prop) => y)) (C.I))) (fun (m0:nat) => fun (_x_419:le (S n) m0) => (fun (_x_421:not_zero m0) => (((((((sym_eq_match_nat_type_S) (Prop)) (C.False)) (fun (p:nat) => C.True)) (m0)) (fun (y:Prop) => y)) (C.I))))) (m)) (Hlt)).
Definition le_S_S : forall (n:nat), forall (m:nat), (le n m) -> le (S n) (S m) := fun (n:nat) => fun (m:nat) => fun (lenm:le n m) => (((((((le_ind) (n)) (fun (x_417:nat) => le (S n) (S x_417))) ((le_n) (S n))) (fun (m0:nat) => fun (_x_419:le n m0) => (fun (_x_421:le (S n) (S m0)) => ((((le_S) (S n)) (S m0)) (_x_421))))) (m)) (lenm)).
Definition le_O_n : forall (n:nat), le O n := fun (n:nat) => ((((nat_ind) (le O)) ((le_n) (O))) (fun (x_366:nat) => fun (_x_368:le O x_366) => ((((le_S) (O)) (x_366)) (_x_368)))) (n).
Definition le_n_Sn : forall (n:nat), le n (S n) := fun (n:nat) => (((le_S) (n)) (n)) ((le_n) (n)).
Definition transitive_le : R.transitive (nat) le := fun (a:nat) => fun (b:nat) => fun (c:nat) => fun (leab:le a b) => (fun (lebc:le b c) => (((((((le_ind) (b)) (fun (x_417:nat) => le a x_417)) (leab)) (fun (m:nat) => fun (_x_419:le b m) => (fun (_x_421:le a m) => ((((le_S) (a)) (m)) (_x_421))))) (c)) (lebc))).
Definition le_pred_n : forall (n:nat), le (pred n) n := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => le (pred _x_365) _x_365)) ((((((eq_match_nat_type_O) (nat)) (O)) (fun (p:nat) => p)) (fun (y:nat) => le (match_nat_type (nat) O (fun (p:nat) => p) O) y)) ((le_n) (pred O)))) (fun (x_366:nat) => fun (_x_368:le (pred x_366) x_366) => (((((((eq_match_nat_type_S) (nat)) (O)) (fun (p:nat) => p)) (x_366)) (fun (y:nat) => le (pred (S x_366)) (S y))) ((le_n_Sn) (pred (S x_366)))))) (n).
Definition monotonic_pred : R.monotonic (nat) le pred := fun (n:nat) => fun (m:nat) => fun (lenm:le n m) => (((((((le_ind) (n)) (fun (x_417:nat) => le (pred n) (pred x_417))) ((le_n) (pred n))) (fun (m0:nat) => fun (_x_419:le n m0) => (fun (_x_421:le (pred n) (pred m0)) => ((((((transitive_le) (pred n)) (n)) (pred (S m0))) ((le_pred_n) (n))) (((((((sym_eq_match_nat_type_S) (nat)) (O)) (fun (p:nat) => p)) (m0)) (fun (y:nat) => le n y)) (_x_419)))))) (m)) (lenm)).
Definition monotonic_le_plus_r : forall (n:nat), R.monotonic (nat) le (fun (m:nat) => plus n m) := fun (n:nat) => fun (a:nat) => fun (b:nat) => ((((nat_ind) (fun (_x_365:nat) => (le a b) -> le (plus _x_365 a) (plus _x_365 b))) ((((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => (le a b) -> le (plus O a) (y b))) ((((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => (le a b) -> le (y a) (filter_nat_type (nat -> nat) plus_body O b))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => (le a b) -> le (y a) (filter_nat_type (nat -> nat) plus_body O b))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => (le a b) -> le (plus_body O a) (y b))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => (le a b) -> le (plus_body O a) (y b))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => (le a b) -> le (y a) b)) (fun (auto:le a b) => (auto))))))))) (fun (m:nat) => fun (H:(le a b) -> le (plus m a) (plus m b)) => (fun (leab:le a b) => ((((sym_eq_plus) (S m)) (fun (y:(nat -> nat)) => le (plus (S m) a) (y b))) ((((sym_eq_plus) (S m)) (fun (y:(nat -> nat)) => le (y a) (filter_nat_type (nat -> nat) plus_body (S m) b))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (m)) (fun (y:(nat -> nat)) => le (y a) (filter_nat_type (nat -> nat) plus_body (S m) b))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (m)) (fun (y:(nat -> nat)) => le (plus_body (S m) a) (y b))) ((((sym_eq_plus_body_S) (m)) (fun (y:(nat -> nat)) => le (plus_body (S m) a) (y b))) ((((sym_eq_plus_body_S) (m)) (fun (y:(nat -> nat)) => le (y a) (S (plus m b)))) ((((le_S_S) (plus m a)) (plus m b)) ((H) (leab)))))))))))) (n).
Definition monotonic_le_plus_l : forall (m:nat), R.monotonic (nat) le (fun (n:nat) => plus n m) := fun (m:nat) => fun (x:nat) => fun (y:nat) => fun (auto:le x y) => (((((G.eq_coerc) (le (plus m x) (plus m y))) (le (plus x m) (plus y m))) (((((monotonic_le_plus_r) (m)) (x)) (y)) (auto))) (((((((G.rewrite_r) (nat)) (plus m x)) (fun (__:nat) => G.eq (Prop) (le (plus m x) (plus m y)) (le __ (plus y m)))) (((((((G.rewrite_r) (nat)) (plus m y)) (fun (__:nat) => G.eq (Prop) (le (plus m x) (plus m y)) (le (plus m x) __))) (((G.refl) (Prop)) (le (plus m x) (plus m y)))) (plus y m)) (((commutative_plus) (y)) (m)))) (plus x m)) (((commutative_plus) (x)) (m)))).
Definition le_plus : forall (n1:nat), forall (n2:nat), forall (m1:nat), forall (m2:nat), (le n1 n2) -> (le m1 m2) -> le (plus n1 m1) (plus n2 m2) := fun (n1:nat) => fun (n2:nat) => fun (m1:nat) => fun (m2:nat) => fun (len:le n1 n2) => (fun (lem:le m1 m2) => ((((((transitive_le) (plus n1 m1)) (plus n1 m2)) (plus n2 m2)) (((((monotonic_le_plus_r) (n1)) (m1)) (m2)) (lem))) (((((monotonic_le_plus_l) (m2)) (n1)) (n2)) (len)))).
Definition le_plus_n : forall (n:nat), forall (m:nat), le m (plus n m) := fun (n:nat) => fun (m:nat) => ((((G.eq_coerc) (le (plus O m) (plus n m))) (le m (plus n m))) (((((monotonic_le_plus_l) (m)) (O)) (n)) ((le_O_n) (n)))) (((((((G.rewrite_l) (nat)) (m)) (fun (__:nat) => G.eq (Prop) (le __ (plus n m)) (le m (plus n m)))) (((G.refl) (Prop)) (le m (plus n m)))) (plus O m)) ((plus_O_n) (m))).
Definition le_plus_n_r : forall (n:nat), forall (m:nat), le m (plus m n) := fun (n:nat) => fun (m:nat) => ((((G.eq_coerc) (le m (plus n m))) (le m (plus m n))) (((le_plus_n) (n)) (m))) (((((((G.rewrite_r) (nat)) (plus n m)) (fun (__:nat) => G.eq (Prop) (le m (plus n m)) (le m __))) (((G.refl) (Prop)) (le m (plus n m)))) (plus m n)) (((commutative_plus) (m)) (n))).
Definition transitive_lt : R.transitive (nat) lt := fun (a:nat) => fun (b:nat) => fun (c:nat) => fun (ltab:lt a b) => (fun (ltbc:lt b c) => (((((((le_ind) (S b)) (fun (x_417:nat) => lt a x_417)) ((((le_S) (S a)) (b)) (ltab))) (fun (m:nat) => fun (_x_419:le (S b) m) => (fun (_x_421:lt a m) => ((((le_S) (S a)) (m)) (_x_421))))) (c)) (ltbc))).
Definition lt_to_le_to_lt : forall (n:nat), forall (m:nat), forall (p:nat), (lt n m) -> (le m p) -> lt n p := fun (n:nat) => fun (m:nat) => fun (p:nat) => fun (H:lt n m) => (fun (H1:le m p) => (((((((le_ind) (m)) (fun (x_417:nat) => lt n x_417)) (H)) (fun (m0:nat) => fun (_x_419:le m m0) => (fun (_x_421:lt n m0) => ((((((transitive_lt) (n)) (m0)) (S m0)) (_x_421)) (((((G.eq_coerc) (le (S m0) (plus O (S m0)))) (le (S m0) (S m0))) (((le_plus_n) (O)) (S m0))) (((((((G.rewrite_l) (nat)) (S m0)) (fun (__:nat) => G.eq (Prop) (le (S m0) __) (le (S m0) (S m0)))) (((G.refl) (Prop)) (le (S m0) (S m0)))) (plus O (S m0))) ((plus_O_n) (S m0)))))))) (p)) (H1))).
Definition le_to_lt_to_lt : forall (n:nat), forall (m:nat), forall (p:nat), (le n m) -> (lt m p) -> lt n p := fun (n:nat) => fun (m:nat) => fun (p:nat) => fun (H:le n m) => (((((((le_ind) (n)) (fun (x_417:nat) => (lt x_417 p) -> lt n p)) (fun (auto:lt n p) => (auto))) (fun (m0:nat) => fun (_x_419:le n m0) => (fun (_x_421:(lt m0 p) -> lt n p) => (fun (auto:lt (S m0) p) => ((_x_421) ((((((transitive_lt) (m0)) (S m0)) (p)) (((((G.eq_coerc) (le (S m0) (plus O (S m0)))) (le (S m0) (S m0))) (((le_plus_n) (O)) (S m0))) (((((((G.rewrite_l) (nat)) (S m0)) (fun (__:nat) => G.eq (Prop) (le (S m0) __) (le (S m0) (S m0)))) (((G.refl) (Prop)) (le (S m0) (S m0)))) (plus O (S m0))) ((plus_O_n) (S m0))))) (auto))))))) (m)) (H)).
Definition ltn_to_ltO : forall (n:nat), forall (m:nat), (lt n m) -> lt O m := fun (n:nat) => fun (m:nat) => fun (auto:lt n m) => ((((((lt_to_le_to_lt) (O)) (S n)) (m)) (((((G.eq_coerc) (le (S O) (plus n (S O)))) (le (S O) (S n))) (((le_plus_n) (n)) (S O))) (((((((G.rewrite_l) (nat)) (S n)) (fun (__:nat) => G.eq (Prop) (le (S O) __) (le (S O) (S n)))) (((G.refl) (Prop)) (le (S O) (S n)))) (plus n (S O))) (((((((G.rewrite_r) (nat)) (plus n O)) (fun (__:nat) => G.eq (nat) (S __) (plus n (S O)))) (((plus_n_Sm) (n)) (O))) (n)) ((plus_n_O) (n)))))) (auto)).
Definition lt_O_S : forall (n:nat), lt O (S n) := fun (n:nat) => (((ltn_to_ltO) (n)) (S n)) (((((G.eq_coerc) (le (S n) (plus O (S n)))) (le (S n) (S n))) (((le_plus_n) (O)) (S n))) (((((((G.rewrite_l) (nat)) (S n)) (fun (__:nat) => G.eq (Prop) (le (S n) __) (le (S n) (S n)))) (((G.refl) (Prop)) (le (S n) (S n)))) (plus O (S n))) ((plus_O_n) (S n)))).
Definition monotonic_lt_plus_r : forall (n:nat), R.monotonic (nat) lt (fun (m:nat) => plus n m) := fun (n:nat) => fun (x:nat) => fun (y:nat) => fun (auto:lt x y) => (((((G.eq_coerc) (le (plus n (S x)) (plus n y))) (le (S (plus n x)) (plus n y))) (((((monotonic_le_plus_r) (n)) (S x)) (y)) (auto))) (((((((G.rewrite_r) (nat)) (plus n (S x))) (fun (__:nat) => G.eq (Prop) (le (plus n (S x)) (plus n y)) (le __ (plus n y)))) (((G.refl) (Prop)) (le (plus n (S x)) (plus n y)))) (S (plus n x))) (((plus_n_Sm) (n)) (x)))).
Definition not_le_Sn_O : forall (n:nat), C.Not (le (S n) O) := fun (n:nat) => ((C.nmk) (le (S n) O)) (fun (Hlen0:le (S n) O) => ((((((eq_match_nat_type_O) (Prop)) (C.False)) (fun (p:nat) => C.True)) (fun (y:Prop) => y)) ((((lt_to_not_zero) (n)) (O)) (Hlen0)))).
Definition not_le_to_not_le_S_S : forall (n:nat), forall (m:nat), (C.Not (le n m)) -> C.Not (le (S n) (S m)) := fun (n:nat) => fun (m:nat) => fun (auto:C.Not (le n m)) => (((((G.not_to_not) (le (S n) (S m))) (le n m)) (fun (auto':le (S n) (S m)) => (((((G.eq_coerc) (le (pred (S n)) (pred (S m)))) (le n m)) ((((monotonic_pred) (S n)) (S m)) (auto'))) (((((((G.rewrite_l) (nat)) (n)) (fun (__:nat) => G.eq (Prop) (le __ (pred (S m))) (le n m))) (((((((G.rewrite_l) (nat)) (m)) (fun (__:nat) => G.eq (Prop) (le n __) (le n m))) (((G.refl) (Prop)) (le n m))) (pred (S m))) ((pred_Sn) (m)))) (pred (S n))) ((pred_Sn) (n)))))) (auto)).
Definition not_le_S_S_to_not_le : forall (n:nat), forall (m:nat), (C.Not (le (S n) (S m))) -> C.Not (le n m) := fun (n:nat) => fun (m:nat) => fun (auto:C.Not (le (S n) (S m))) => (((((G.not_to_not) (le n m)) (le (S n) (S m))) (fun (auto':le n m) => ((((le_S_S) (n)) (m)) (auto')))) (auto)).
Definition not_le_Sn_n : forall (n:nat), C.Not (le (S n) n) := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => C.Not (le (S _x_365) _x_365))) ((not_le_Sn_O) (O))) (fun (x_366:nat) => fun (_x_368:C.Not (le (S x_366) x_366)) => ((((not_le_to_not_le_S_S) (S x_366)) (x_366)) (_x_368)))) (n).
Definition not_le_to_lt : forall (n:nat), forall (m:nat), (C.Not (le n m)) -> lt m n := ((((nat_elim2) (fun (__:nat) => fun (_0:nat) => (C.Not (le __ _0)) -> lt _0 __)) (fun (n:nat) => fun (abs:C.Not (le O n)) => (((C.falsity) (lt n O)) ((((G.absurd) (le O n)) (((((G.eq_coerc) (le O (plus n O))) (le O n)) (((le_plus_n) (n)) (O))) (((((((G.rewrite_l) (nat)) (n)) (fun (__:nat) => G.eq (Prop) (le O __) (le O n))) (((G.refl) (Prop)) (le O n))) (plus n O)) ((plus_n_O) (n))))) (abs))))) (fun (n:nat) => fun (auto:C.Not (le (S n) O)) => ((lt_O_S) (n)))) (fun (n:nat) => fun (m:nat) => fun (Hind:(C.Not (le n m)) -> lt m n) => (fun (HnotleSS:C.Not (le (S n) (S m))) => ((((le_S_S) (S m)) (n)) ((Hind) ((((not_le_S_S_to_not_le) (n)) (m)) (HnotleSS)))))).
Definition le_to_or_lt_eq : forall (n:nat), forall (m:nat), (le n m) -> C.Or (lt n m) (G.eq (nat) n m) := fun (n:nat) => fun (m:nat) => fun (lenm:le n m) => (((((((le_ind) (n)) (fun (x_417:nat) => C.Or (lt n x_417) (G.eq (nat) n x_417))) ((((R.RC_reflexive) (nat)) (lt)) (n))) (fun (m0:nat) => fun (_x_419:le n m0) => (fun (_x_421:C.Or (lt n m0) (G.eq (nat) n m0)) => ((((C.or_introl) (lt n (S m0))) (G.eq (nat) n (S m0))) ((((((le_to_lt_to_lt) (n)) (m0)) (S m0)) (_x_419)) (((((G.eq_coerc) (le (S m0) (plus O (S m0)))) (le (S m0) (S m0))) (((le_plus_n) (O)) (S m0))) (((((((G.rewrite_l) (nat)) (S m0)) (fun (__:nat) => G.eq (Prop) (le (S m0) __) (le (S m0) (S m0)))) (((G.refl) (Prop)) (le (S m0) (S m0)))) (plus O (S m0))) ((plus_O_n) (S m0))))))))) (m)) (lenm)).
Definition le_n_O_elim : forall (n:nat), (le n O) -> forall (P:(nat -> Prop)), (P O) -> P n := fun (n:nat) => ((((match_nat_prop) (fun (__:nat) => (le __ O) -> forall (P:(nat -> Prop)), (P O) -> P __)) (fun (auto:le O O) => (fun (P:nat -> Prop) => fun (auto':P O) => (auto')))) (fun (a:nat) => fun (abs:le (S a) O) => (((C.falsity) (forall (P:(nat -> Prop)), (P O) -> P (S a))) ((((G.absurd) (le (S a) O)) (abs)) ((not_le_Sn_O) (a)))))) (n).
Definition eqb : nat -> nat -> B.bool := fun (n:nat) => fun (m:nat) => if N.eqb n m then B.true else B.false.
Definition eqb_body : nat -> nat -> B.bool := fun (n:nat) => fun (m:nat) => if N.eqb n m then B.true else B.false.
Definition axiom_eqb : forall (n:nat), C.equal (nat -> B.bool) (eqb n) (filter_nat_type (nat -> B.bool) eqb_body n) := fun (n:nat) => C.equal_refl (nat -> B.bool) (eqb_body n).
Definition eq_eqb : forall (n:nat), L.leibniz (nat -> B.bool) (eqb n) (filter_nat_type (nat -> B.bool) eqb_body n) := fun (n:nat) => ((((C.equal_leibniz) (nat -> B.bool)) (eqb n)) (filter_nat_type (nat -> B.bool) eqb_body n)) ((axiom_eqb) (n)).
Definition sym_eq_eqb : forall (n:nat), L.leibniz (nat -> B.bool) (filter_nat_type (nat -> B.bool) eqb_body n) (eqb n) := fun (n:nat) => ((((L.sym_leibniz) (nat -> B.bool)) (eqb n)) (filter_nat_type (nat -> B.bool) eqb_body n)) ((eq_eqb) (n)).
Definition axiom_eqb_body_O : C.equal (nat -> B.bool) (eqb_body O) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m) := eq_ind (eqb_body O) (fun (f : nat -> B.bool) => C.equal (nat -> B.bool) (eqb_body O) f) (C.equal_refl (nat -> B.bool) (eqb_body O)) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m) (functional_extensionality (eqb_body O) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m) (fun (m:nat) => match m as n return ((if match n with 0%N => true | N.pos _ => false end then B.true else B.false) = match n with 0%N => B.true | N.pos _ => B.false end) with 0%N => eq_refl | N.pos _ => eq_refl end)).
Definition eq_eqb_body_O : L.leibniz (nat -> B.bool) (eqb_body O) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m) := ((((C.equal_leibniz) (nat -> B.bool)) (eqb_body O)) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m)) (axiom_eqb_body_O).
Definition sym_eq_eqb_body_O : L.leibniz (nat -> B.bool) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m) (eqb_body O) := ((((L.sym_leibniz) (nat -> B.bool)) (eqb_body O)) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m)) (eq_eqb_body_O).
Definition eqb_succ_pred : forall (n:nat) (p:positive), N.eqb (S n) (N.pos p) = N.eqb n (Pos.pred_N p) := fun (n : N) (p : positive) => Bool.eq_true_iff_eq match match n with | 0%N => 1%N | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x with | (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end with | 0%N => false | N.pos p0 => (fix eqb (p1 q : positive) {struct q} : bool := match p1 with | (p2~1)%positive => match q with | (q0~1)%positive => eqb p2 q0 | _ => false end | (p2~0)%positive => match q with | (q0~0)%positive => eqb p2 q0 | _ => false end | 1%positive => match q with | 1%positive => true | _ => false end end) p0 p end match n with | 0%N => match match p with | (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x with | (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end with 0%N => true | N.pos _ => false end | N.pos p0 => match match p with (p1~1)%positive => N.pos p1~0 | (p1~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x with (p2~1)%positive => (p2~0~1)%positive | (p2~0)%positive => ((pred_double p2)~1)%positive | 1%positive => 1%positive end) p1) | 1%positive => 0%N end with 0%N => false | N.pos q => (fix eqb (p1 q0 : positive) {struct q0} : bool := match p1 with (p2~1)%positive => match q0 with | (q1~1)%positive => eqb p2 q1 | _ => false end | (p2~0)%positive => match q0 with | (q1~0)%positive => eqb p2 q1 | _ => false end | 1%positive => match q0 with | 1%positive => true | _ => false end end) p0 q end end (conj (fun H : match match n with 0%N => 1%N | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end with 0%N => false | N.pos p0 => (fix eqb (p1 q : positive) {struct q} : bool := match p1 with (p2~1)%positive => match q with | (q0~1)%positive => eqb p2 q0 | _ => false end | (p2~0)%positive => match q with | (q0~0)%positive => eqb p2 q0 | _ => false end | 1%positive => match q with | 1%positive => true | _ => false end end) p0 p end = true => match N.eqb_eq n match p with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0 end with conj _ x0 => x0 end match match match match N.succ_pos_spec n in (_ = a) return (a = N.pos match n with 0%N => 1 | N.pos p0 => (fix succ (x : positive) : positive := match x with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0 end) with eq_refl => eq_refl end in (_ = a) return (a = N.pos p) with eq_refl => match N.eqb_eq match n with N0 => 1 | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end (N.pos p) with conj x _ => x end H end in (_ = a) return (match n with 0%N => 1%positive | N.pos p0 => (fix succ (x : positive) : positive := match x with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0 end = match a with 0%N => match n with 0%N => 1%positive | N.pos p0 => (fix succ (x : positive) : positive := match x with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0 end | N.pos p0 => p0 end) with eq_refl => eq_refl end in (_ = a) return (n = match a with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end) with eq_refl => match N.pos_pred_succ n in (_ = a) return (a = match match n with 0%N => 1%positive | N.pos p0 => (fix succ (x : positive) : positive := match x with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0 end with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end) with | eq_refl => eq_refl end end) (fun H : match n with | 0%N => match match p with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end with | 0%N => true | N.pos _ => false end | N.pos p0 => match match p with (p1~1)%positive => N.pos p1~0 | (p1~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x with (p2~1)%positive => (p2~0~1)%positive | (p2~0)%positive => ((pred_double p2)~1)%positive | 1%positive => 1%positive end) p1) | 1%positive => 0%N end with 0%N => false | N.pos q => (fix eqb (p1 q0 : positive) {struct q0} : bool := match p1 with | (p2~1)%positive => match q0 with (q1~1)%positive => eqb p2 q1 | _ => false end | (p2~0)%positive => match q0 with (q1~0)%positive => eqb p2 q1 | _ => false end | 1%positive => match q0 with 1%positive => true | _ => false end end) p0 q end end = true => match N.eqb_eq match n with N0 => 1 | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end (N.pos p) with conj _ x0 => x0 end match match match N.eqb_eq n match p with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => N0 end with conj x _ => x end H in (_ = a) return (a = n) with eq_refl => eq_refl end in (_ = a) return (match a with 0%N => 1%N | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end = N.pos p) with | eq_refl => N.succ_pos_pred p end)).
Definition axiom_eqb_body_S : forall (n:nat), C.equal (nat -> B.bool) (eqb_body (S n)) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m) := fun (n:nat) => eq_ind (eqb_body (S n)) (fun (f : nat -> B.bool) => C.equal (nat -> B.bool) (eqb_body (S n)) f) (C.equal_refl (nat -> B.bool) (eqb_body (S n))) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m) (functional_extensionality (eqb_body (S n)) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m) (fun (m:nat) => match m as n0 return ((if match match n with 0%N => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with 0%N => match n0 with 0%N => true | N.pos _ => false end | N.pos p => match n0 with 0%N => false | N.pos q => (fix eqb (p0 q0 : positive) {struct q0} : bool := match p0 with (p1~1)%positive => match q0 with (q1~1)%positive => eqb p1 q1 | _ => false end | (p1~0)%positive => match q0 with (q1~0)%positive => eqb p1 q1 | _ => false end | 1%positive => match q0 with 1%positive => true | _ => false end end) p q end end then B.true else B.false) = match n0 with 0%N => B.false | N.pos p => if match n with 0%N => match match p with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end with 0%N => true | N.pos _ => false end | N.pos p0 => match match p with (p1~1)%positive => N.pos p1~0 | (p1~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x with (p2~1)%positive => (p2~0~1)%positive | (p2~0)%positive => ((pred_double p2)~1)%positive | 1%positive => 1%positive end) p1) | 1%positive => 0%N end with 0%N => false | N.pos q => (fix eqb (p1 q0 : positive) {struct q0} : bool := match p1 with (p2~1)%positive => match q0 with (q1~1)%positive => eqb p2 q1 | _ => false end | (p2~0)%positive => match q0 with (q1~0)%positive => eqb p2 q1 | _ => false end | 1%positive => match q0 with 1%positive => true | _ => false end end) p0 q end end then B.true else B.false end) with 0%N => match match proj2 (N.eqb_neq match n with N0 => 1 | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end 0) (N.neq_succ_0 n) in (_ = a) return (a = match match n with 0%N => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end with 0%N => true | N.pos _ => false end) with eq_refl => eq_refl end in (_ = a) return ((if a then B.true else B.false) = B.false) with eq_refl => eq_refl end | N.pos p => match eqb_succ_pred n p in (_ = a) return ((if match match n with 0%N => 1%N | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end with 0%N => false | N.pos p0 => (fix eqb (p1 q : positive) {struct q} : bool := match p1 with (p2~1)%positive => match q with (q0~1)%positive => eqb p2 q0 | _ => false end | (p2~0)%positive => match q with (q0~0)%positive => eqb p2 q0 | _ => false end | 1%positive => match q with 1%positive => true | _ => false end end) p0 p end then B.true else B.false) = (if a then B.true else B.false)) with eq_refl => eq_refl end end)).
Definition eq_eqb_body_S : forall (n:nat), L.leibniz (nat -> B.bool) (eqb_body (S n)) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m) := fun (n:nat) => ((((C.equal_leibniz) (nat -> B.bool)) (eqb_body (S n))) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m)) ((axiom_eqb_body_S) (n)).
Definition sym_eq_eqb_body_S : forall (n:nat), L.leibniz (nat -> B.bool) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m) (eqb_body (S n)) := fun (n:nat) => ((((L.sym_leibniz) (nat -> B.bool)) (eqb_body (S n))) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m)) ((eq_eqb_body_S) (n)).
Definition eqb_elim : forall (n:nat), forall (m:nat), forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m) := ((((nat_elim2) (fun (__:nat) => fun (_0:nat) => forall (P:(B.bool -> Prop)), ((G.eq (nat) __ _0) -> P B.true) -> ((C.Not (G.eq (nat) __ _0)) -> P B.false) -> P (eqb __ _0))) (fun (n:nat) => ((((match_nat_prop) (fun (__:nat) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O __) -> P B.true) -> ((C.Not (G.eq (nat) O __)) -> P B.false) -> P (eqb O __))) ((((sym_eq_eqb) (O)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O O) -> P B.true) -> ((C.Not (G.eq (nat) O O)) -> P B.false) -> P (y O))) (((((sym_eq_filter_nat_type_O) (nat -> B.bool)) (eqb_body)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O O) -> P B.true) -> ((C.Not (G.eq (nat) O O)) -> P B.false) -> P (y O))) (((sym_eq_eqb_body_O) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O O) -> P B.true) -> ((C.Not (G.eq (nat) O O)) -> P B.false) -> P (y O))) ((((((sym_eq_match_nat_type_O) (B.bool)) (B.true)) (fun (q:nat) => B.false)) (fun (y:B.bool) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O O) -> P B.true) -> ((C.Not (G.eq (nat) O O)) -> P B.false) -> P y)) (fun (P:B.bool -> Prop) => fun (auto:(G.eq (nat) O O) -> P B.true) => (fun (auto':(C.Not (G.eq (nat) O O)) -> P B.false) => ((auto) (((G.refl) (nat)) (O)))))))))) (fun (auto:nat) => (((sym_eq_eqb) (O)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O (S auto)) -> P B.true) -> ((C.Not (G.eq (nat) O (S auto))) -> P B.false) -> P (y (S auto)))) (((((sym_eq_filter_nat_type_O) (nat -> B.bool)) (eqb_body)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O (S auto)) -> P B.true) -> ((C.Not (G.eq (nat) O (S auto))) -> P B.false) -> P (y (S auto)))) (((sym_eq_eqb_body_O) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O (S auto)) -> P B.true) -> ((C.Not (G.eq (nat) O (S auto))) -> P B.false) -> P (y (S auto)))) (((((((sym_eq_match_nat_type_S) (B.bool)) (B.true)) (fun (q:nat) => B.false)) (auto)) (fun (y:B.bool) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O (S auto)) -> P B.true) -> ((C.Not (G.eq (nat) O (S auto))) -> P B.false) -> P y)) (fun (P:B.bool -> Prop) => fun (auto':(G.eq (nat) O (S auto)) -> P B.true) => (fun (auto'':(C.Not (G.eq (nat) O (S auto))) -> P B.false) => ((auto'') ((not_eq_O_S) (auto)))))))))) (n))) (fun (n:nat) => (((sym_eq_eqb) (S n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) O) -> P B.true) -> ((C.Not (G.eq (nat) (S n) O)) -> P B.false) -> P (y O))) ((((((sym_eq_filter_nat_type_S) (nat -> B.bool)) (eqb_body)) (n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) O) -> P B.true) -> ((C.Not (G.eq (nat) (S n) O)) -> P B.false) -> P (y O))) ((((sym_eq_eqb_body_S) (n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) O) -> P B.true) -> ((C.Not (G.eq (nat) (S n) O)) -> P B.false) -> P (y O))) ((((((sym_eq_match_nat_type_O) (B.bool)) (B.false)) (fun (q:nat) => eqb n q)) (fun (y:B.bool) => forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) O) -> P B.true) -> ((C.Not (G.eq (nat) (S n) O)) -> P B.false) -> P y)) (fun (P:B.bool -> Prop) => fun (auto:(G.eq (nat) (S n) O) -> P B.true) => (fun (auto':(C.Not (G.eq (nat) (S n) O)) -> P B.false) => ((auto') (((((G.sym_not_eq) (nat)) (O)) (S n)) ((not_eq_O_S) (n))))))))))) (fun (n:nat) => fun (m:nat) => (((sym_eq_eqb) (S n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m)) -> forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) (S m)) -> P B.true) -> ((C.Not (G.eq (nat) (S n) (S m))) -> P B.false) -> P (y (S m)))) ((((((sym_eq_filter_nat_type_S) (nat -> B.bool)) (eqb_body)) (n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m)) -> forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) (S m)) -> P B.true) -> ((C.Not (G.eq (nat) (S n) (S m))) -> P B.false) -> P (y (S m)))) ((((sym_eq_eqb_body_S) (n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m)) -> forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) (S m)) -> P B.true) -> ((C.Not (G.eq (nat) (S n) (S m))) -> P B.false) -> P (y (S m)))) (((((((sym_eq_match_nat_type_S) (B.bool)) (B.false)) (fun (q:nat) => eqb n q)) (m)) (fun (y:B.bool) => (forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m)) -> forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) (S m)) -> P B.true) -> ((C.Not (G.eq (nat) (S n) (S m))) -> P B.false) -> P y)) (fun (auto:forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m)) => (fun (P:B.bool -> Prop) => fun (auto':(G.eq (nat) (S n) (S m)) -> P B.true) => (fun (auto'':(C.Not (G.eq (nat) (S n) (S m))) -> P B.false) => ((((auto) (P)) (fun (auto''':G.eq (nat) n m) => ((auto') (((((((G.rewrite_l) (nat)) (n)) (fun (__:nat) => G.eq (nat) (S n) (S __))) (((G.refl) (nat)) (S n))) (m)) (auto'''))))) (fun (auto''':C.Not (G.eq (nat) n m)) => ((auto'') ((((not_eq_S) (n)) (m)) (auto''')))))))))))).
Definition eqb_false_to_not_eq : forall (n:nat), forall (m:nat), (G.eq (B.bool) (eqb n m) B.false) -> C.Not (G.eq (nat) n m) := fun (n:nat) => fun (m:nat) => (((((eqb_elim) (n)) (m)) (fun (__:B.bool) => (G.eq (B.bool) __ B.false) -> C.Not (G.eq (nat) n m))) (fun (auto:G.eq (nat) n m) => (fun (auto':G.eq (B.bool) B.true B.false) => (((((G.not_to_not) (G.eq (nat) n m)) (G.eq (B.bool) B.true B.false)) (fun (auto'':G.eq (nat) n m) => (((((((G.rewrite_l) (B.bool)) (B.true)) (fun (__:B.bool) => G.eq (B.bool) B.true __)) (((G.refl) (B.bool)) (B.true))) (B.false)) (auto')))) (B.not_eq_true_false))))) (fun (auto:C.Not (G.eq (nat) n m)) => (fun (auto':G.eq (B.bool) B.false B.false) => (auto))).
Definition leb : nat -> nat -> B.bool := fun (n:nat) => fun (m:nat) => if N.leb n m then B.true else B.false.
Definition leb_body : nat -> nat -> B.bool := fun (n:nat) => fun (m:nat) => if N.leb n m then B.true else B.false.
Definition axiom_leb : forall (n:nat), C.equal (nat -> B.bool) (leb n) (filter_nat_type (nat -> B.bool) leb_body n) := fun (n:nat) => C.equal_refl (nat -> B.bool) (leb_body n).
Definition eq_leb : forall (n:nat), L.leibniz (nat -> B.bool) (leb n) (filter_nat_type (nat -> B.bool) leb_body n) := fun (n:nat) => ((((C.equal_leibniz) (nat -> B.bool)) (leb n)) (filter_nat_type (nat -> B.bool) leb_body n)) ((axiom_leb) (n)).
Definition sym_eq_leb : forall (n:nat), L.leibniz (nat -> B.bool) (filter_nat_type (nat -> B.bool) leb_body n) (leb n) := fun (n:nat) => ((((L.sym_leibniz) (nat -> B.bool)) (leb n)) (filter_nat_type (nat -> B.bool) leb_body n)) ((eq_leb) (n)).
Definition axiom_leb_body_O : C.equal (nat -> B.bool) (leb_body O) (fun (m:nat) => B.true)  := eq_ind (leb_body O) (fun (f : nat -> B.bool) => C.equal (nat -> B.bool) (leb_body O) f) (C.equal_refl (nat -> B.bool) (leb_body O)) (fun (m:nat) => B.true) (functional_extensionality (fun (m:nat) => if N.leb N0 m then B.true else B.false) (fun (_:nat) => B.true) (fun (m:nat) => f_equal (fun (b:bool) => if b then B.true else B.false) (proj2 (N.leb_le 0 m) (N.le_0_l m)))).
Definition eq_leb_body_O : L.leibniz (nat -> B.bool) (leb_body O) (fun (m:nat) => B.true) := ((((C.equal_leibniz) (nat -> B.bool)) (leb_body O)) (fun (m:nat) => B.true)) (axiom_leb_body_O).
Definition sym_eq_leb_body_O : L.leibniz (nat -> B.bool) (fun (m:nat) => B.true) (leb_body O) := ((((L.sym_leibniz) (nat -> B.bool)) (leb_body O)) (fun (m:nat) => B.true)) (eq_leb_body_O).
Definition axiom_leb_body_S : forall (n:nat), C.equal (nat -> B.bool) (leb_body (S n)) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m) := fun (n:nat) => eq_ind (leb_body (S n)) (fun (f : nat -> B.bool) => C.equal (nat -> B.bool) (leb_body (S n)) f) (C.equal_refl (nat -> B.bool) (leb_body (S n))) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m) (functional_extensionality (leb_body (S n)) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m) (fun (m:nat) => match m as n0 return ((if match match match n  with 0%N => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x  with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end  with 0%N => match n0  with 0%N => Eq | N.pos _ => Lt end | N.pos n' => match n0  with 0%N => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x  with (p~1)%positive => match y  with (q~1)%positive => compare_cont r p q | (q~0)%positive => compare_cont Gt p q | 1%positive => Gt end | (p~0)%positive => match y  with (q~1)%positive => compare_cont Lt p q | (q~0)%positive => compare_cont r p q | 1%positive => Gt end | 1%positive => match y  with 1%positive => r | _ => Lt end end) Eq n' m' end end  with Gt => false | _ => true end then B.true else B.false) = match n0  with 0%N => B.false | N.pos p => if match match n  with 0%N => match match p  with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x  with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end  with 0%N => Eq | N.pos _ => Lt end | N.pos n' => match match p  with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x  with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end  with 0%N => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x  with (p0~1)%positive => match y  with (q~1)%positive => compare_cont r p0 q | (q~0)%positive => compare_cont Gt p0 q | 1%positive => Gt end | (p0~0)%positive => match y  with (q~1)%positive => compare_cont Lt p0 q | (q~0)%positive => compare_cont r p0 q | 1%positive => Gt end | 1%positive => match y  with 1%positive => r | _ => Lt end end) Eq n' m' end end  with Gt => false | _ => true end then B.true else B.false end)  with 0%N => match match proj2 (N.leb_nle match n  with N0 => 1 | N.pos p => N.pos ((fix succ (x : positive) : positive := match x  with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end 0) (N.nle_succ_0 n) in (_ = a) return (a = match match match n  with 0%N => 1%N | N.pos p => N.pos ((fix succ (x : positive) : positive := match x  with (p0~1)%positive => ((succ p0)~0)%positive | (p0~0)%positive => (p0~1)%positive | 1%positive => 2%positive end) p) end  with 0%N => Eq | N.pos _ => Gt end  with Gt => false | _ => true end)  with eq_refl => eq_refl end in (_ = a) return ((if a then B.true else B.false) = B.false)  with eq_refl => eq_refl end | N.pos p => match Bool.eq_true_iff_eq match match match n  with 0%N => 1%N | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x  with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end  with 0%N => Lt | N.pos n' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x  with (p0~1)%positive => match y  with (q~1)%positive => compare_cont r p0 q | (q~0)%positive => compare_cont Gt p0 q | 1%positive => Gt end | (p0~0)%positive => match y  with (q~1)%positive => compare_cont Lt p0 q | (q~0)%positive => compare_cont r p0 q | 1%positive => Gt end | 1%positive => match y  with 1%positive => r | _ => Lt end end) Eq n' p end  with Gt => false | _ => true end match match n  with 0%N => match match p  with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x  with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end  with 0%N => Eq | N.pos _ => Lt end | N.pos n' => match match p  with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x  with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end  with 0%N => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x  with (p0~1)%positive => match y  with (q~1)%positive => compare_cont r p0 q | (q~0)%positive => compare_cont Gt p0 q | 1%positive => Gt end | (p0~0)%positive => match y  with (q~1)%positive => compare_cont Lt p0 q | (q~0)%positive => compare_cont r p0 q | 1%positive => Gt end | 1%positive => match y  with 1%positive => r | _ => Lt end end) Eq n' m' end end  with Gt => false | _ => true end (conj (fun H : match match match n  with 0%N => 1%N | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x  with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end  with 0%N => Lt | N.pos n' => (fix compare_cont (r : comparison)  (x y : positive) {struct y} : comparison := match x  with (p0~1)%positive => match y  with (q~1)%positive => compare_cont r p0 q | (q~0)%positive => compare_cont Gt p0 q | 1%positive => Gt end | (p0~0)%positive => match y  with (q~1)%positive => compare_cont Lt p0 q | (q~0)%positive => compare_cont r p0 q | 1%positive => Gt end | 1%positive => match y  with 1%positive => r | _ => Lt end end) Eq n' p end  with Gt => false | _ => true end = true => match N.leb_le n match p  with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x : positive) : positive := match x  with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => N0 end  with conj _ x0 => x0 end match match N.pos_pred_spec p in (_ = a) return (a = match p  with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double  (x : positive) : positive := match x  with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end)  with eq_refl => eq_refl end in (_ = a) return (match n  with 0%N => match a  with 0%N => Eq | N.pos _ => Lt end | N.pos n' => match a  with 0%N => Gt | N.pos m' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x  with (p0~1)%positive => match y  with (q~1)%positive => compare_cont r p0 q | (q~0)%positive => compare_cont Gt p0 q | 1%positive => Gt end | (p0~0)%positive => match y  with (q~1)%positive => compare_cont Lt p0 q | (q~0)%positive => compare_cont r p0 q | 1%positive => Gt end | 1%positive => match y  with 1%positive => r | _ => Lt end end) Eq n' m' end end = Gt -> False)  with eq_refl => N.le_succ_le_pred n (N.pos p) (match N.leb_le match n  with N0 => 1 | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x  with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end (N.pos p)  with conj x _ => x end H) end) (fun H : match match n  with 0%N => match match p  with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double  (x : positive) : positive := match x  with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end  with 0%N => Eq | N.pos _ => Lt end | N.pos n' => match match p  with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double  (x : positive) : positive := match x  with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => 0%N end  with 0%N => Gt | N.pos m' => (fix compare_cont (r : comparison)  (x y : positive) {struct y} : comparison := match x  with (p0~1)%positive => match y  with (q~1)%positive => compare_cont r p0 q | (q~0)%positive => compare_cont Gt p0 q | 1%positive => Gt end | (p0~0)%positive => match y  with (q~1)%positive => compare_cont Lt p0 q | (q~0)%positive => compare_cont r p0 q | 1%positive => Gt end | 1%positive => match y  with 1%positive => r | _ => Lt end end) Eq n' m' end end  with Gt => false | _ => true end = true => match N.leb_le match n  with N0 => 1 | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x  with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end (N.pos p)  with conj _ x0 => x0 end match N.succ_pos_pred p in (_ = a) return (match match n  with 0%N => 1%N | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x  with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end  with 0%N => match a  with 0%N => Eq | N.pos _ => Lt end | N.pos n' => match a  with 0%N => Gt | N.pos m' => (fix compare_cont (r : comparison)  (x y : positive) {struct y} : comparison := match x  with (p0~1)%positive => match y  with (q~1)%positive => compare_cont r p0 q | (q~0)%positive => compare_cont Gt p0 q | 1%positive => Gt end | (p0~0)%positive => match y  with (q~1)%positive => compare_cont Lt p0 q | (q~0)%positive => compare_cont r p0 q | 1%positive => Gt end | 1%positive => match y  with 1%positive => r | _ => Lt end end) Eq n' m' end end = Gt -> False)  with eq_refl => match N.succ_le_mono n match p  with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double  (x : positive) : positive := match x  with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => N0 end  with conj x _ => x (match N.leb_le n match p  with (p0~1)%positive => N.pos p0~0 | (p0~0)%positive => N.pos ((fix pred_double (x1 : positive) : positive := match x1  with (p1~1)%positive => (p1~0~1)%positive | (p1~0)%positive => ((pred_double p1)~1)%positive | 1%positive => 1%positive end) p0) | 1%positive => N0 end  with conj x1 _ => x1 end H) end end)) in (_ = a) return ((if match match match n  with 0%N => 1%N | N.pos p0 => N.pos ((fix succ (x : positive) : positive := match x  with (p1~1)%positive => ((succ p1)~0)%positive | (p1~0)%positive => (p1~1)%positive | 1%positive => 2%positive end) p0) end  with 0%N => Lt | N.pos n' => (fix compare_cont (r : comparison) (x y : positive) {struct y} : comparison := match x  with (p0~1)%positive => match y  with (q~1)%positive => compare_cont r p0 q | (q~0)%positive => compare_cont Gt p0 q | 1%positive => Gt end | (p0~0)%positive => match y  with (q~1)%positive => compare_cont Lt p0 q | (q~0)%positive => compare_cont r p0 q | 1%positive => Gt end | 1%positive => match y  with 1%positive => r | _ => Lt end end) Eq n' p end  with Gt => false | _ => true end then B.true else B.false) = (if a then B.true else B.false))  with eq_refl => eq_refl end end)).
Definition eq_leb_body_S : forall (n:nat), L.leibniz (nat -> B.bool) (leb_body (S n)) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m) := fun (n:nat) => ((((C.equal_leibniz) (nat -> B.bool)) (leb_body (S n))) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m)) ((axiom_leb_body_S) (n)).
Definition sym_eq_leb_body_S : forall (n:nat), L.leibniz (nat -> B.bool) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m) (leb_body (S n)) := fun (n:nat) => ((((L.sym_leibniz) (nat -> B.bool)) (leb_body (S n))) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m)) ((eq_leb_body_S) (n)).
Definition leb_elim : forall (n:nat), forall (m:nat), forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m) := ((((nat_elim2) (fun (__:nat) => fun (_0:nat) => forall (P:(B.bool -> Prop)), ((le __ _0) -> P B.true) -> ((C.Not (le __ _0)) -> P B.false) -> P (leb __ _0))) (fun (n:nat) => (((sym_eq_leb) (O)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le O n) -> P B.true) -> ((C.Not (le O n)) -> P B.false) -> P (y n))) (((((sym_eq_filter_nat_type_O) (nat -> B.bool)) (leb_body)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le O n) -> P B.true) -> ((C.Not (le O n)) -> P B.false) -> P (y n))) (((sym_eq_leb_body_O) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le O n) -> P B.true) -> ((C.Not (le O n)) -> P B.false) -> P (y n))) (fun (P:B.bool -> Prop) => fun (auto:(le O n) -> P B.true) => (fun (auto':(C.Not (le O n)) -> P B.false) => ((auto) ((le_O_n) (n))))))))) (fun (n:nat) => (((sym_eq_leb) (S n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le (S n) O) -> P B.true) -> ((C.Not (le (S n) O)) -> P B.false) -> P (y O))) ((((((sym_eq_filter_nat_type_S) (nat -> B.bool)) (leb_body)) (n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le (S n) O) -> P B.true) -> ((C.Not (le (S n) O)) -> P B.false) -> P (y O))) ((((sym_eq_leb_body_S) (n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le (S n) O) -> P B.true) -> ((C.Not (le (S n) O)) -> P B.false) -> P (y O))) ((((((sym_eq_match_nat_type_O) (B.bool)) (B.false)) (fun (q:nat) => leb n q)) (fun (y:B.bool) => forall (P:(B.bool -> Prop)), ((le (S n) O) -> P B.true) -> ((C.Not (le (S n) O)) -> P B.false) -> P y)) (fun (P:B.bool -> Prop) => fun (auto:(le (S n) O) -> P B.true) => (fun (auto':(C.Not (le (S n) O)) -> P B.false) => ((auto') ((not_le_Sn_O) (n)))))))))) (fun (n:nat) => fun (m:nat) => (((sym_eq_leb) (S n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m)) -> forall (P:(B.bool -> Prop)), ((le (S n) (S m)) -> P B.true) -> ((C.Not (le (S n) (S m))) -> P B.false) -> P (y (S m)))) ((((((sym_eq_filter_nat_type_S) (nat -> B.bool)) (leb_body)) (n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m)) -> forall (P:(B.bool -> Prop)), ((le (S n) (S m)) -> P B.true) -> ((C.Not (le (S n) (S m))) -> P B.false) -> P (y (S m)))) ((((sym_eq_leb_body_S) (n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m)) -> forall (P:(B.bool -> Prop)), ((le (S n) (S m)) -> P B.true) -> ((C.Not (le (S n) (S m))) -> P B.false) -> P (y (S m)))) (((((((sym_eq_match_nat_type_S) (B.bool)) (B.false)) (fun (q:nat) => leb n q)) (m)) (fun (y:B.bool) => (forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m)) -> forall (P:(B.bool -> Prop)), ((le (S n) (S m)) -> P B.true) -> ((C.Not (le (S n) (S m))) -> P B.false) -> P y)) (fun (Hind:forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m)) => (fun (P:B.bool -> Prop) => fun (Pt:(le (S n) (S m)) -> P B.true) => (fun (Pf:(C.Not (le (S n) (S m))) -> P B.false) => ((((Hind) (P)) (fun (lenm:le n m) => ((Pt) ((((le_S_S) (n)) (m)) (lenm))))) (fun (nlenm:C.Not (le n m)) => ((Pf) ((((not_le_to_not_le_S_S) (n)) (m)) (nlenm)))))))))))).
End Binnat_make.

Module Coq_binnat <: Nat_Type Coq_connectives Coq_leibniz Coq_logic Coq_relations Coq_bool := Binnat_make Coq_connectives Coq_leibniz Coq_logic Coq_relations Coq_bool.

