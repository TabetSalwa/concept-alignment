Require Import connectives_type.
Require Import leibniz_type.
Require Import logic_type.
Require Import relations_type.
Require Import bool_type.
Require Import nat_type.
Require Import nat_morphism_type.
Require Import connectives_coq.
Require Import leibniz_coq.
Require Import logic_coq.
Require Import relations_coq.
Require Import bool_coq.
Require Import unnat_coq.
Require Import binnat_coq.
Require Import Coq.NArith.Nnat.
Require Import BinNat.
Require Import BinNums.
Require Import BinPosDef.
Require Import BinPos.


Module Nat_binnat_make (C : Connectives_Type) (L : Leibniz_Type) (G : Logic_Type C) (R : Relations_Type C G) (B : Bool_Type C L G R).
Module N1 := Nat_make C L G R B.
Module N2 := Binnat_make C L G R B.
Definition f := N.of_nat.
Definition image_O : C.equal N (f 0) N0 := C.equal_refl N N0.
Definition image_S : forall (n:nat), C.equal N (f (S n)) (N.succ (f n)) := fun (n:nat) => eq_ind (f (S n)) (fun (m:N) => C.equal N (f (S n)) m) (C.equal_refl N (f (S n))) (N.succ (f n)) (Nat2N.inj_succ n).
Definition image_plus : forall (n m:N1.nat), C.equal N2.nat (f (N1.plus n m)) (N2.plus (f n) (f m)) := fun (n m : N1.nat) => N1.nat_ind (fun n0 : N1.nat => C.equal N2.nat (f (N1.plus n0 m)) (N2.plus (f n0) (f m))) (C.equal_leibniz (N1.nat -> N1.nat) (fun n0 : N1.nat => n0) (N1.plus N1.O) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus N1.O) (fun n0 : N1.nat => n0) (C.equal_leibniz (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O) (N1.plus N1.O) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus N1.O) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O)  (N1.axiom_plus N1.O) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.plus N1.O)) (C.equal_refl (N1.nat -> N1.nat) (N1.plus N1.O))) (fun n0 : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) n0 (fun n1 : N1.nat => n1)) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus_body N1.O) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O) (C.equal_leibniz (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O)  (N1.plus_body N1.O) (N1.axiom_filter_nat_type_O (N1.nat -> N1.nat) N1.plus_body) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O)) (C.equal_refl (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O))) (fun n0 : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) n0 (fun n1 : N1.nat => n1)) N1.axiom_plus_body_O)) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.plus N1.O)) (C.equal_refl (N1.nat -> N1.nat) (N1.plus N1.O))) (fun n0 : N1.nat -> N1.nat => C.equal N2.nat (f (n0 m)) (N2.plus (f N1.O) (f m))) (C.equal_leibniz N2.nat N2.O (f N1.O) (C.equal_leibniz N2.nat (f N1.O) N2.O image_O (fun y : N2.nat => C.equal N2.nat y (f N1.O)) (C.equal_refl N2.nat (f N1.O))) (fun n0 : N2.nat => C.equal N2.nat (f m) (N2.plus n0 (f m))) (C.equal_leibniz (N2.nat -> N2.nat) (fun n0 : N2.nat => n0) (N2.plus N2.O) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus N2.O) (fun n0 : N2.nat => n0) (C.equal_leibniz (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O)  (N2.plus N2.O) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus N2.O) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O)  (N2.axiom_plus N2.O) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.plus N2.O)) (C.equal_refl (N2.nat -> N2.nat) (N2.plus N2.O))) (fun n0 : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) n0 (fun n1 : N2.nat => n1)) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus_body N2.O) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O) (C.equal_leibniz (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O) (N2.plus_body N2.O) (N2.axiom_filter_nat_type_O (N2.nat -> N2.nat) N2.plus_body) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O)) (C.equal_refl (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O))) (fun n0 : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) n0 (fun n1 : N2.nat => n1)) N2.axiom_plus_body_O)) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.plus N2.O)) (C.equal_refl (N2.nat -> N2.nat) (N2.plus N2.O))) (fun n0 : N2.nat -> N2.nat => C.equal N2.nat (f m) (n0 (f m))) (C.equal_refl N2.nat (f m))))) (fun (x : N1.nat) (Hx : C.equal N2.nat (f (N1.plus x m)) (N2.plus (f x) (f m))) => C.equal_leibniz (N1.nat -> N1.nat) (fun n0 : N1.nat => N1.S (N1.plus x n0))  (N1.plus (N1.S x)) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus (N1.S x)) (fun n0 : N1.nat => N1.S (N1.plus x n0)) (C.equal_leibniz (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x))  (N1.plus (N1.S x)) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus (N1.S x)) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x)) (N1.axiom_plus (N1.S x)) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.plus (N1.S x))) (C.equal_refl (N1.nat -> N1.nat) (N1.plus (N1.S x)))) (fun n0 : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) n0 (fun m0 : N1.nat => N1.S (N1.plus x m0))) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus_body (N1.S x)) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x)) (C.equal_leibniz (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x)) (N1.plus_body (N1.S x)) (N1.axiom_filter_nat_type_S (N1.nat -> N1.nat) N1.plus_body x) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x))) (C.equal_refl (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x)))) (fun n0 : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) n0 (fun m0 : N1.nat => N1.S (N1.plus x m0))) (N1.axiom_plus_body_S x))) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.plus (N1.S x))) (C.equal_refl (N1.nat -> N1.nat) (N1.plus (N1.S x)))) (fun n0 : N1.nat -> N1.nat => C.equal N2.nat (f (n0 m)) (N2.plus (f (N1.S x)) (f m))) (C.equal_leibniz N2.nat (N2.S (f (N1.plus x m))) (f (N1.S (N1.plus x m))) (C.equal_leibniz N2.nat (f (N1.S (N1.plus x m))) (N2.S (f (N1.plus x m))) (image_S (N1.plus x m)) (fun y : N2.nat => C.equal N2.nat y (f (N1.S (N1.plus x m)))) (C.equal_refl N2.nat (f (N1.S (N1.plus x m))))) (fun n0 : N2.nat => C.equal N2.nat n0 (N2.plus (f (N1.S x)) (f m))) (C.equal_leibniz N2.nat (N2.S (f x)) (f (N1.S x)) (C.equal_leibniz N2.nat (f (N1.S x)) (N2.S (f x)) (image_S x) (fun y : N2.nat => C.equal N2.nat y (f (N1.S x))) (C.equal_refl N2.nat (f (N1.S x)))) (fun n0 : N2.nat => C.equal N2.nat (N2.S (f (N1.plus x m))) (N2.plus n0 (f m))) (C.equal_leibniz (N2.nat -> N2.nat) (fun n0 : N2.nat => N2.S (N2.plus (f x) n0)) (N2.plus (N2.S (f x))) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus (N2.S (f x))) (fun n0 : N2.nat => N2.S (N2.plus (f x) n0)) (C.equal_leibniz (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x))) (N2.plus (N2.S (f x))) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus (N2.S (f x))) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x))) (N2.axiom_plus (N2.S (f x))) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.plus (N2.S (f x)))) (C.equal_refl (N2.nat -> N2.nat) (N2.plus (N2.S (f x))))) (fun n0 : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) n0 (fun m0 : N2.nat => N2.S (N2.plus (f x) m0))) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus_body (N2.S (f x))) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x))) (C.equal_leibniz (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x))) (N2.plus_body (N2.S (f x))) (N2.axiom_filter_nat_type_S (N2.nat -> N2.nat) N2.plus_body (f x)) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x)))) (C.equal_refl (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x))))) (fun n0 : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) n0 (fun m0 : N2.nat => N2.S (N2.plus (f x) m0))) (N2.axiom_plus_body_S (f x)))) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.plus (N2.S (f x)))) (C.equal_refl (N2.nat -> N2.nat) (N2.plus (N2.S (f x))))) (fun n0 : N2.nat -> N2.nat => C.equal N2.nat (N2.S (f (N1.plus x m))) (n0 (f m))) (C.equal_leibniz N2.nat (f (N1.plus x m)) (N2.plus (f x) (f m)) Hx (fun y : N2.nat => C.equal N2.nat (N2.S (f (N1.plus x m))) (N2.S y)) (C.equal_refl N2.nat (N2.S (f (N1.plus x m))))))))) n.
Definition morph_injective : R.injective N1.nat N2.nat f := fun (n : N1.nat) => N1.nat_ind (fun n0 : N1.nat => forall m : N1.nat, G.eq N2.nat (f n0) (f m) -> G.eq N1.nat n0 m) (C.equal_leibniz N2.nat N2.O (f N1.O) (C.equal_leibniz N2.nat (f N1.O) N2.O image_O (fun y : N2.nat => C.equal N2.nat y (f N1.O)) (C.equal_refl N2.nat (f N1.O))) (fun n0 : N2.nat => forall m : N1.nat, G.eq N2.nat n0 (f m) -> G.eq N1.nat N1.O m) (fun m : N1.nat => N1.nat_ind (fun _x_365 : N1.nat => (G.eq N1.nat _x_365 N1.O -> G.eq N2.nat N2.O (f N1.O) -> G.eq N1.nat N1.O N1.O) -> (forall m0 : N1.nat, G.eq N1.nat _x_365 (N1.S m0) -> G.eq N2.nat N2.O (f (N1.S m0)) -> G.eq N1.nat N1.O (N1.S m0)) -> G.eq N2.nat N2.O (f _x_365) -> G.eq N1.nat N1.O _x_365) (fun (auto : G.eq N1.nat N1.O N1.O -> G.eq N2.nat N2.O (f N1.O) -> G.eq N1.nat N1.O N1.O) (_ : forall m0 : N1.nat, G.eq N1.nat N1.O (N1.S m0) -> G.eq N2.nat N2.O (f (N1.S m0)) -> G.eq N1.nat N1.O (N1.S m0)) => auto (G.refl N1.nat N1.O)) (fun (x_366 : N1.nat) (_ : (G.eq N1.nat x_366 N1.O -> G.eq N2.nat N2.O (f N1.O) -> G.eq N1.nat N1.O N1.O) -> (forall m0 : N1.nat, G.eq N1.nat x_366 (N1.S m0) -> G.eq N2.nat N2.O (f (N1.S m0)) -> G.eq N1.nat N1.O (N1.S m0)) -> G.eq N2.nat N2.O (f x_366) -> G.eq N1.nat N1.O x_366) (_ : G.eq N1.nat (N1.S x_366) N1.O -> G.eq N2.nat N2.O (f N1.O) -> G.eq N1.nat N1.O N1.O) (auto' : forall m0 : N1.nat, G.eq N1.nat (N1.S x_366) (N1.S m0) -> G.eq N2.nat N2.O (f (N1.S m0)) -> G.eq N1.nat N1.O (N1.S m0)) => auto' x_366 (G.refl N1.nat (N1.S x_366))) m (fun (_ : G.eq N1.nat m N1.O) (_ : G.eq N2.nat N2.O (f N1.O)) => G.refl N1.nat N1.O) (fun (m0 : N1.nat) (_ : G.eq N1.nat m (N1.S m0)) => C.equal_leibniz N2.nat (N2.S (f m0)) (f (N1.S m0)) (C.equal_leibniz N2.nat (f (N1.S m0)) (N2.S (f m0)) (image_S m0) (fun y : N2.nat => C.equal N2.nat y (f (N1.S m0))) (C.equal_refl N2.nat (f (N1.S m0)))) (fun n0 : N2.nat => G.eq N2.nat N2.O n0 -> G.eq N1.nat N1.O (N1.S m0)) (C.Not_ind (G.eq N2.nat N2.O (N2.S (f m0))) (G.eq N2.nat N2.O (N2.S (f m0)) -> G.eq N1.nat N1.O (N1.S m0)) (fun (H1 : G.eq N2.nat N2.O (N2.S (f m0)) -> C.False) (H2 : G.eq N2.nat N2.O (N2.S (f m0))) => C.falsity (G.eq N1.nat N1.O (N1.S m0)) (H1 H2)) (C.nmk (G.eq N2.nat N2.O (N2.S (f m0))) (fun eqOS : G.eq N2.nat N2.O (N2.S (f m0)) => C.equal_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) N2.O) C.False (N2.axiom_match_nat_type_O Prop C.False (fun _ : N2.nat => C.True)) (fun y : Prop => y) (G.eq_ind_r N2.nat (N2.S (f m0)) (fun x : N2.nat => N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) x) (L.sym_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) (N2.S (f m0))) C.True (C.equal_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) (N2.S (f m0))) C.True (N2.axiom_match_nat_type_S Prop C.False (fun _ : N2.nat => C.True) (f m0))) (fun y : Prop => y) C.I) N2.O eqOS))))))) (fun (x : N1.nat) (Hx : forall m : N1.nat, G.eq N2.nat (f x) (f m) -> G.eq N1.nat x m) (m : N1.nat) => C.equal_leibniz N2.nat (N2.S (f x)) (f (N1.S x)) (C.equal_leibniz N2.nat (f (N1.S x)) (N2.S (f x)) (image_S x) (fun y : N2.nat => C.equal N2.nat y (f (N1.S x))) (C.equal_refl N2.nat (f (N1.S x)))) (fun n0 : N2.nat => G.eq N2.nat n0 (f m) -> G.eq N1.nat (N1.S x) m) (N1.nat_ind (fun _x_365 : N1.nat => (G.eq N1.nat _x_365 N1.O -> G.eq N2.nat (N2.S (f x)) (f N1.O) -> G.eq N1.nat (N1.S x) N1.O) -> (forall m0 : N1.nat, G.eq N1.nat _x_365 (N1.S m0) -> G.eq N2.nat (N2.S (f x)) (f (N1.S m0)) -> G.eq N1.nat (N1.S x) (N1.S m0)) -> G.eq N2.nat (N2.S (f x)) (f _x_365) -> G.eq N1.nat (N1.S x) _x_365) (fun (auto : G.eq N1.nat N1.O N1.O -> G.eq N2.nat (N2.S (f x)) (f N1.O) -> G.eq N1.nat (N1.S x) N1.O) (_ : forall m0 : N1.nat, G.eq N1.nat N1.O (N1.S m0) -> G.eq N2.nat (N2.S (f x)) (f (N1.S m0)) -> G.eq N1.nat (N1.S x) (N1.S m0)) => auto (G.refl N1.nat N1.O)) (fun (x_366 : N1.nat) (_ : (G.eq N1.nat x_366 N1.O -> G.eq N2.nat (N2.S (f x)) (f N1.O) -> G.eq N1.nat (N1.S x) N1.O) -> (forall m0 : N1.nat, G.eq N1.nat x_366 (N1.S m0) -> G.eq N2.nat (N2.S (f x)) (f (N1.S m0)) -> G.eq N1.nat (N1.S x) (N1.S m0)) -> G.eq N2.nat (N2.S (f x)) (f x_366) -> G.eq N1.nat (N1.S x) x_366) (_ : G.eq N1.nat (N1.S x_366) N1.O -> G.eq N2.nat (N2.S (f x)) (f N1.O) -> G.eq N1.nat (N1.S x) N1.O) (auto' : forall m0 : N1.nat, G.eq N1.nat (N1.S x_366) (N1.S m0) -> G.eq N2.nat (N2.S (f x)) (f (N1.S m0)) -> G.eq N1.nat (N1.S x) (N1.S m0)) => auto' x_366 (G.refl N1.nat (N1.S x_366))) m (fun _ : G.eq N1.nat m N1.O => C.equal_leibniz N2.nat N2.O (f N1.O) (C.equal_leibniz N2.nat (f N1.O) N2.O image_O (fun y : N2.nat => C.equal N2.nat y (f N1.O)) (C.equal_refl N2.nat (f N1.O))) (fun n0 : N2.nat => G.eq N2.nat (N2.S (f x)) n0 -> G.eq N1.nat (N1.S x) N1.O) (C.Not_ind (G.eq N2.nat N2.O (N2.S (f x))) (G.eq N2.nat (N2.S (f x)) N2.O -> G.eq N1.nat (N1.S x) N1.O) (fun (H1 : G.eq N2.nat N2.O (N2.S (f x)) -> C.False) (H2 : G.eq N2.nat (N2.S (f x)) N2.O) => C.falsity (G.eq N1.nat (N1.S x) N1.O) (H1 (G.sym_eq N2.nat (N2.S (f x)) N2.O H2))) (C.nmk (G.eq N2.nat N2.O (N2.S (f x))) (fun eqOS : G.eq N2.nat N2.O (N2.S (f x)) => C.equal_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) N2.O) C.False (N2.axiom_match_nat_type_O Prop C.False (fun _ : N2.nat => C.True)) (fun y : Prop => y) (G.eq_ind_r N2.nat (N2.S (f x)) (fun x0 : N2.nat => N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) x0) (L.sym_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) (N2.S (f x))) C.True (C.equal_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) (N2.S (f x))) C.True (N2.axiom_match_nat_type_S Prop C.False (fun _ : N2.nat => C.True) (f x))) (fun y : Prop => y) C.I) N2.O eqOS))))) (fun (m0 : N1.nat) (_ : G.eq N1.nat m (N1.S m0)) => C.equal_leibniz N2.nat (N2.S (f m0)) (f (N1.S m0)) (C.equal_leibniz N2.nat (f (N1.S m0)) (N2.S (f m0)) (image_S m0) (fun y : N2.nat => C.equal N2.nat y (f (N1.S m0))) (C.equal_refl N2.nat (f (N1.S m0)))) (fun n0 : N2.nat => G.eq N2.nat (N2.S (f x)) n0 -> G.eq N1.nat (N1.S x) (N1.S m0)) (fun Heq : G.eq N2.nat (N2.S (f x)) (N2.S (f m0)) => G.eq_ind N1.nat x (fun y : N1.nat => G.eq N1.nat (N1.S x) (N1.S y)) (G.refl N1.nat (N1.S x)) m0 (Hx m0 (G.rewrite_l N2.nat (f m0) (fun __ : N2.nat => G.eq N2.nat __ (f m0)) (G.refl N2.nat (f m0)) (f x) (G.rewrite_r N2.nat (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) (N2.S (f x))) (fun __ : N2.nat => G.eq N2.nat (f m0) __) (G.rewrite_r N2.nat (N2.S (f m0)) (fun __ : N2.nat => G.eq N2.nat (f m0) (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) __)) (L.sym_leibniz N2.nat (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) (N2.S (f m0))) (f m0) (C.equal_leibniz N2.nat (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) (N2.S (f m0))) (f m0) (N2.axiom_match_nat_type_S N2.nat N2.O  (fun p : N2.nat => p) (f m0))) (fun y : N2.nat => G.eq N2.nat (f m0) y)  (G.refl N2.nat (f m0))) (N2.S (f x)) Heq)  (f x) (L.sym_leibniz N2.nat (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) (N2.S (f x))) (f x) (C.equal_leibniz N2.nat (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) (N2.S (f x))) (f x) (N2.axiom_match_nat_type_S N2.nat N2.O (fun p : N2.nat => p) (f x))) (fun y : N2.nat => G.eq N2.nat (f x) y) (G.refl N2.nat (f x)))))))))) n.
Definition morph_surjective : forall (m : N2.nat), exists (n : N1.nat), C.equal N2.nat (f n) m := fun (m : N2.nat) => N2.nat_ind (fun m0 : N2.nat => exists n : N1.nat, C.equal N2.nat (f n) m0) (ex_intro (fun n : N1.nat => C.equal N2.nat (f n) N2.O) N1.O image_O) (fun (m0 : N2.nat) (Hm : exists n : N1.nat, C.equal N2.nat (f n) m0) => match Hm with | ex_intro _ x x0 => ex_intro (fun n : N1.nat => C.equal N2.nat (f n) (N2.S m0)) (N1.S x) (C.equal_leibniz N2.nat (N2.S (f x)) (f (N1.S x)) (C.equal_leibniz N2.nat (f (N1.S x)) (N2.S (f x)) (image_S x) (fun y : N2.nat => C.equal N2.nat y (f (N1.S x))) (C.equal_refl N2.nat (f (N1.S x)))) (fun n : N2.nat => C.equal N2.nat n (N2.S m0)) (C.equal_leibniz N2.nat (f x) m0 x0 (fun y : N2.nat => C.equal N2.nat (N2.S (f x)) (N2.S y)) (C.equal_refl N2.nat (N2.S (f x))))) end) m.
End Nat_binnat_make.

Module Coq_nat_binnat <: Nat_morphism Coq_connectives Coq_leibniz Coq_logic Coq_relations Coq_bool Coq_nat Coq_binnat := Nat_binnat_make Coq_connectives Coq_leibniz Coq_logic Coq_relations Coq_bool.


Module Binnat_nat_make (C : Connectives_Type) (L : Leibniz_Type) (G : Logic_Type C) (R : Relations_Type C G) (B : Bool_Type C L G R).
Module N1 := Binnat_make C L G R B.
Module N2 := Nat_make C L G R B.
Definition f := N.to_nat.
Definition image_O : C.equal nat (f N0) 0 := C.equal_refl nat 0.
Definition image_S : forall (n:N), C.equal nat (f (N.succ n)) (S (f n)) := fun (n:N) => eq_ind (f (N.succ n)) (fun (m:nat) => C.equal nat (f (N.succ n)) m) (C.equal_refl nat (f (N.succ n))) (S (f n)) (N2Nat.inj_succ n).
Definition image_plus : forall (n m:N1.nat), C.equal N2.nat (f (N1.plus n m)) (N2.plus (f n) (f m)) := fun (n m : N1.nat) => N1.nat_ind (fun n0 : N1.nat => C.equal N2.nat (f (N1.plus n0 m)) (N2.plus (f n0) (f m))) (C.equal_leibniz (N1.nat -> N1.nat) (fun n0 : N1.nat => n0) (N1.plus N1.O) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus N1.O) (fun n0 : N1.nat => n0) (C.equal_leibniz (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O) (N1.plus N1.O) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus N1.O) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O)  (N1.axiom_plus N1.O) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.plus N1.O)) (C.equal_refl (N1.nat -> N1.nat) (N1.plus N1.O))) (fun n0 : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) n0 (fun n1 : N1.nat => n1)) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus_body N1.O) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O) (C.equal_leibniz (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O)  (N1.plus_body N1.O) (N1.axiom_filter_nat_type_O (N1.nat -> N1.nat) N1.plus_body) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O)) (C.equal_refl (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body N1.O))) (fun n0 : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) n0 (fun n1 : N1.nat => n1)) N1.axiom_plus_body_O)) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.plus N1.O)) (C.equal_refl (N1.nat -> N1.nat) (N1.plus N1.O))) (fun n0 : N1.nat -> N1.nat => C.equal N2.nat (f (n0 m)) (N2.plus (f N1.O) (f m))) (C.equal_leibniz N2.nat N2.O (f N1.O) (C.equal_leibniz N2.nat (f N1.O) N2.O image_O (fun y : N2.nat => C.equal N2.nat y (f N1.O)) (C.equal_refl N2.nat (f N1.O))) (fun n0 : N2.nat => C.equal N2.nat (f m) (N2.plus n0 (f m))) (C.equal_leibniz (N2.nat -> N2.nat) (fun n0 : N2.nat => n0) (N2.plus N2.O) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus N2.O) (fun n0 : N2.nat => n0) (C.equal_leibniz (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O)  (N2.plus N2.O) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus N2.O) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O)  (N2.axiom_plus N2.O) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.plus N2.O)) (C.equal_refl (N2.nat -> N2.nat) (N2.plus N2.O))) (fun n0 : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) n0 (fun n1 : N2.nat => n1)) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus_body N2.O) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O) (C.equal_leibniz (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O) (N2.plus_body N2.O) (N2.axiom_filter_nat_type_O (N2.nat -> N2.nat) N2.plus_body) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O)) (C.equal_refl (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body N2.O))) (fun n0 : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) n0 (fun n1 : N2.nat => n1)) N2.axiom_plus_body_O)) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.plus N2.O)) (C.equal_refl (N2.nat -> N2.nat) (N2.plus N2.O))) (fun n0 : N2.nat -> N2.nat => C.equal N2.nat (f m) (n0 (f m))) (C.equal_refl N2.nat (f m))))) (fun (x : N1.nat) (Hx : C.equal N2.nat (f (N1.plus x m)) (N2.plus (f x) (f m))) => C.equal_leibniz (N1.nat -> N1.nat) (fun n0 : N1.nat => N1.S (N1.plus x n0))  (N1.plus (N1.S x)) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus (N1.S x)) (fun n0 : N1.nat => N1.S (N1.plus x n0)) (C.equal_leibniz (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x))  (N1.plus (N1.S x)) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus (N1.S x)) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x)) (N1.axiom_plus (N1.S x)) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.plus (N1.S x))) (C.equal_refl (N1.nat -> N1.nat) (N1.plus (N1.S x)))) (fun n0 : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) n0 (fun m0 : N1.nat => N1.S (N1.plus x m0))) (C.equal_leibniz (N1.nat -> N1.nat) (N1.plus_body (N1.S x)) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x)) (C.equal_leibniz (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x)) (N1.plus_body (N1.S x)) (N1.axiom_filter_nat_type_S (N1.nat -> N1.nat) N1.plus_body x) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x))) (C.equal_refl (N1.nat -> N1.nat) (N1.filter_nat_type (N1.nat -> N1.nat) N1.plus_body (N1.S x)))) (fun n0 : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) n0 (fun m0 : N1.nat => N1.S (N1.plus x m0))) (N1.axiom_plus_body_S x))) (fun y : N1.nat -> N1.nat => C.equal (N1.nat -> N1.nat) y (N1.plus (N1.S x))) (C.equal_refl (N1.nat -> N1.nat) (N1.plus (N1.S x)))) (fun n0 : N1.nat -> N1.nat => C.equal N2.nat (f (n0 m)) (N2.plus (f (N1.S x)) (f m))) (C.equal_leibniz N2.nat (N2.S (f (N1.plus x m))) (f (N1.S (N1.plus x m))) (C.equal_leibniz N2.nat (f (N1.S (N1.plus x m))) (N2.S (f (N1.plus x m))) (image_S (N1.plus x m)) (fun y : N2.nat => C.equal N2.nat y (f (N1.S (N1.plus x m)))) (C.equal_refl N2.nat (f (N1.S (N1.plus x m))))) (fun n0 : N2.nat => C.equal N2.nat n0 (N2.plus (f (N1.S x)) (f m))) (C.equal_leibniz N2.nat (N2.S (f x)) (f (N1.S x)) (C.equal_leibniz N2.nat (f (N1.S x)) (N2.S (f x)) (image_S x) (fun y : N2.nat => C.equal N2.nat y (f (N1.S x))) (C.equal_refl N2.nat (f (N1.S x)))) (fun n0 : N2.nat => C.equal N2.nat (N2.S (f (N1.plus x m))) (N2.plus n0 (f m))) (C.equal_leibniz (N2.nat -> N2.nat) (fun n0 : N2.nat => N2.S (N2.plus (f x) n0)) (N2.plus (N2.S (f x))) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus (N2.S (f x))) (fun n0 : N2.nat => N2.S (N2.plus (f x) n0)) (C.equal_leibniz (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x))) (N2.plus (N2.S (f x))) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus (N2.S (f x))) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x))) (N2.axiom_plus (N2.S (f x))) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.plus (N2.S (f x)))) (C.equal_refl (N2.nat -> N2.nat) (N2.plus (N2.S (f x))))) (fun n0 : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) n0 (fun m0 : N2.nat => N2.S (N2.plus (f x) m0))) (C.equal_leibniz (N2.nat -> N2.nat) (N2.plus_body (N2.S (f x))) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x))) (C.equal_leibniz (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x))) (N2.plus_body (N2.S (f x))) (N2.axiom_filter_nat_type_S (N2.nat -> N2.nat) N2.plus_body (f x)) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x)))) (C.equal_refl (N2.nat -> N2.nat) (N2.filter_nat_type (N2.nat -> N2.nat) N2.plus_body (N2.S (f x))))) (fun n0 : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) n0 (fun m0 : N2.nat => N2.S (N2.plus (f x) m0))) (N2.axiom_plus_body_S (f x)))) (fun y : N2.nat -> N2.nat => C.equal (N2.nat -> N2.nat) y (N2.plus (N2.S (f x)))) (C.equal_refl (N2.nat -> N2.nat) (N2.plus (N2.S (f x))))) (fun n0 : N2.nat -> N2.nat => C.equal N2.nat (N2.S (f (N1.plus x m))) (n0 (f m))) (C.equal_leibniz N2.nat (f (N1.plus x m)) (N2.plus (f x) (f m)) Hx (fun y : N2.nat => C.equal N2.nat (N2.S (f (N1.plus x m))) (N2.S y)) (C.equal_refl N2.nat (N2.S (f (N1.plus x m))))))))) n.
Definition morph_injective : R.injective N1.nat N2.nat f := fun (n : N1.nat) => N1.nat_ind (fun n0 : N1.nat => forall m : N1.nat, G.eq N2.nat (f n0) (f m) -> G.eq N1.nat n0 m) (C.equal_leibniz N2.nat N2.O (f N1.O) (C.equal_leibniz N2.nat (f N1.O) N2.O image_O (fun y : N2.nat => C.equal N2.nat y (f N1.O)) (C.equal_refl N2.nat (f N1.O))) (fun n0 : N2.nat => forall m : N1.nat, G.eq N2.nat n0 (f m) -> G.eq N1.nat N1.O m) (fun m : N1.nat => N1.nat_ind (fun _x_365 : N1.nat => (G.eq N1.nat _x_365 N1.O -> G.eq N2.nat N2.O (f N1.O) -> G.eq N1.nat N1.O N1.O) -> (forall m0 : N1.nat, G.eq N1.nat _x_365 (N1.S m0) -> G.eq N2.nat N2.O (f (N1.S m0)) -> G.eq N1.nat N1.O (N1.S m0)) -> G.eq N2.nat N2.O (f _x_365) -> G.eq N1.nat N1.O _x_365) (fun (auto : G.eq N1.nat N1.O N1.O -> G.eq N2.nat N2.O (f N1.O) -> G.eq N1.nat N1.O N1.O) (_ : forall m0 : N1.nat, G.eq N1.nat N1.O (N1.S m0) -> G.eq N2.nat N2.O (f (N1.S m0)) -> G.eq N1.nat N1.O (N1.S m0)) => auto (G.refl N1.nat N1.O)) (fun (x_366 : N1.nat) (_ : (G.eq N1.nat x_366 N1.O -> G.eq N2.nat N2.O (f N1.O) -> G.eq N1.nat N1.O N1.O) -> (forall m0 : N1.nat, G.eq N1.nat x_366 (N1.S m0) -> G.eq N2.nat N2.O (f (N1.S m0)) -> G.eq N1.nat N1.O (N1.S m0)) -> G.eq N2.nat N2.O (f x_366) -> G.eq N1.nat N1.O x_366) (_ : G.eq N1.nat (N1.S x_366) N1.O -> G.eq N2.nat N2.O (f N1.O) -> G.eq N1.nat N1.O N1.O) (auto' : forall m0 : N1.nat, G.eq N1.nat (N1.S x_366) (N1.S m0) -> G.eq N2.nat N2.O (f (N1.S m0)) -> G.eq N1.nat N1.O (N1.S m0)) => auto' x_366 (G.refl N1.nat (N1.S x_366))) m (fun (_ : G.eq N1.nat m N1.O) (_ : G.eq N2.nat N2.O (f N1.O)) => G.refl N1.nat N1.O) (fun (m0 : N1.nat) (_ : G.eq N1.nat m (N1.S m0)) => C.equal_leibniz N2.nat (N2.S (f m0)) (f (N1.S m0)) (C.equal_leibniz N2.nat (f (N1.S m0)) (N2.S (f m0)) (image_S m0) (fun y : N2.nat => C.equal N2.nat y (f (N1.S m0))) (C.equal_refl N2.nat (f (N1.S m0)))) (fun n0 : N2.nat => G.eq N2.nat N2.O n0 -> G.eq N1.nat N1.O (N1.S m0)) (C.Not_ind (G.eq N2.nat N2.O (N2.S (f m0))) (G.eq N2.nat N2.O (N2.S (f m0)) -> G.eq N1.nat N1.O (N1.S m0)) (fun (H1 : G.eq N2.nat N2.O (N2.S (f m0)) -> C.False) (H2 : G.eq N2.nat N2.O (N2.S (f m0))) => C.falsity (G.eq N1.nat N1.O (N1.S m0)) (H1 H2)) (C.nmk (G.eq N2.nat N2.O (N2.S (f m0))) (fun eqOS : G.eq N2.nat N2.O (N2.S (f m0)) => C.equal_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) N2.O) C.False (N2.axiom_match_nat_type_O Prop C.False (fun _ : N2.nat => C.True)) (fun y : Prop => y) (G.eq_ind_r N2.nat (N2.S (f m0)) (fun x : N2.nat => N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) x) (L.sym_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) (N2.S (f m0))) C.True (C.equal_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) (N2.S (f m0))) C.True (N2.axiom_match_nat_type_S Prop C.False (fun _ : N2.nat => C.True) (f m0))) (fun y : Prop => y) C.I) N2.O eqOS))))))) (fun (x : N1.nat) (Hx : forall m : N1.nat, G.eq N2.nat (f x) (f m) -> G.eq N1.nat x m) (m : N1.nat) => C.equal_leibniz N2.nat (N2.S (f x)) (f (N1.S x)) (C.equal_leibniz N2.nat (f (N1.S x)) (N2.S (f x)) (image_S x) (fun y : N2.nat => C.equal N2.nat y (f (N1.S x))) (C.equal_refl N2.nat (f (N1.S x)))) (fun n0 : N2.nat => G.eq N2.nat n0 (f m) -> G.eq N1.nat (N1.S x) m) (N1.nat_ind (fun _x_365 : N1.nat => (G.eq N1.nat _x_365 N1.O -> G.eq N2.nat (N2.S (f x)) (f N1.O) -> G.eq N1.nat (N1.S x) N1.O) -> (forall m0 : N1.nat, G.eq N1.nat _x_365 (N1.S m0) -> G.eq N2.nat (N2.S (f x)) (f (N1.S m0)) -> G.eq N1.nat (N1.S x) (N1.S m0)) -> G.eq N2.nat (N2.S (f x)) (f _x_365) -> G.eq N1.nat (N1.S x) _x_365) (fun (auto : G.eq N1.nat N1.O N1.O -> G.eq N2.nat (N2.S (f x)) (f N1.O) -> G.eq N1.nat (N1.S x) N1.O) (_ : forall m0 : N1.nat, G.eq N1.nat N1.O (N1.S m0) -> G.eq N2.nat (N2.S (f x)) (f (N1.S m0)) -> G.eq N1.nat (N1.S x) (N1.S m0)) => auto (G.refl N1.nat N1.O)) (fun (x_366 : N1.nat) (_ : (G.eq N1.nat x_366 N1.O -> G.eq N2.nat (N2.S (f x)) (f N1.O) -> G.eq N1.nat (N1.S x) N1.O) -> (forall m0 : N1.nat, G.eq N1.nat x_366 (N1.S m0) -> G.eq N2.nat (N2.S (f x)) (f (N1.S m0)) -> G.eq N1.nat (N1.S x) (N1.S m0)) -> G.eq N2.nat (N2.S (f x)) (f x_366) -> G.eq N1.nat (N1.S x) x_366) (_ : G.eq N1.nat (N1.S x_366) N1.O -> G.eq N2.nat (N2.S (f x)) (f N1.O) -> G.eq N1.nat (N1.S x) N1.O) (auto' : forall m0 : N1.nat, G.eq N1.nat (N1.S x_366) (N1.S m0) -> G.eq N2.nat (N2.S (f x)) (f (N1.S m0)) -> G.eq N1.nat (N1.S x) (N1.S m0)) => auto' x_366 (G.refl N1.nat (N1.S x_366))) m (fun _ : G.eq N1.nat m N1.O => C.equal_leibniz N2.nat N2.O (f N1.O) (C.equal_leibniz N2.nat (f N1.O) N2.O image_O (fun y : N2.nat => C.equal N2.nat y (f N1.O)) (C.equal_refl N2.nat (f N1.O))) (fun n0 : N2.nat => G.eq N2.nat (N2.S (f x)) n0 -> G.eq N1.nat (N1.S x) N1.O) (C.Not_ind (G.eq N2.nat N2.O (N2.S (f x))) (G.eq N2.nat (N2.S (f x)) N2.O -> G.eq N1.nat (N1.S x) N1.O) (fun (H1 : G.eq N2.nat N2.O (N2.S (f x)) -> C.False) (H2 : G.eq N2.nat (N2.S (f x)) N2.O) => C.falsity (G.eq N1.nat (N1.S x) N1.O) (H1 (G.sym_eq N2.nat (N2.S (f x)) N2.O H2))) (C.nmk (G.eq N2.nat N2.O (N2.S (f x))) (fun eqOS : G.eq N2.nat N2.O (N2.S (f x)) => C.equal_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) N2.O) C.False (N2.axiom_match_nat_type_O Prop C.False (fun _ : N2.nat => C.True)) (fun y : Prop => y) (G.eq_ind_r N2.nat (N2.S (f x)) (fun x0 : N2.nat => N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) x0) (L.sym_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) (N2.S (f x))) C.True (C.equal_leibniz Prop (N2.match_nat_type Prop C.False (fun _ : N2.nat => C.True) (N2.S (f x))) C.True (N2.axiom_match_nat_type_S Prop C.False (fun _ : N2.nat => C.True) (f x))) (fun y : Prop => y) C.I) N2.O eqOS))))) (fun (m0 : N1.nat) (_ : G.eq N1.nat m (N1.S m0)) => C.equal_leibniz N2.nat (N2.S (f m0)) (f (N1.S m0)) (C.equal_leibniz N2.nat (f (N1.S m0)) (N2.S (f m0)) (image_S m0) (fun y : N2.nat => C.equal N2.nat y (f (N1.S m0))) (C.equal_refl N2.nat (f (N1.S m0)))) (fun n0 : N2.nat => G.eq N2.nat (N2.S (f x)) n0 -> G.eq N1.nat (N1.S x) (N1.S m0)) (fun Heq : G.eq N2.nat (N2.S (f x)) (N2.S (f m0)) => G.eq_ind N1.nat x (fun y : N1.nat => G.eq N1.nat (N1.S x) (N1.S y)) (G.refl N1.nat (N1.S x)) m0 (Hx m0 (G.rewrite_l N2.nat (f m0) (fun __ : N2.nat => G.eq N2.nat __ (f m0)) (G.refl N2.nat (f m0)) (f x) (G.rewrite_r N2.nat (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) (N2.S (f x))) (fun __ : N2.nat => G.eq N2.nat (f m0) __) (G.rewrite_r N2.nat (N2.S (f m0)) (fun __ : N2.nat => G.eq N2.nat (f m0) (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) __)) (L.sym_leibniz N2.nat (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) (N2.S (f m0))) (f m0) (C.equal_leibniz N2.nat (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) (N2.S (f m0))) (f m0) (N2.axiom_match_nat_type_S N2.nat N2.O  (fun p : N2.nat => p) (f m0))) (fun y : N2.nat => G.eq N2.nat (f m0) y)  (G.refl N2.nat (f m0))) (N2.S (f x)) Heq)  (f x) (L.sym_leibniz N2.nat (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) (N2.S (f x))) (f x) (C.equal_leibniz N2.nat (N2.match_nat_type N2.nat N2.O (fun p : N2.nat => p) (N2.S (f x))) (f x) (N2.axiom_match_nat_type_S N2.nat N2.O (fun p : N2.nat => p) (f x))) (fun y : N2.nat => G.eq N2.nat (f x) y) (G.refl N2.nat (f x)))))))))) n.
Definition morph_surjective : forall (m : N2.nat), exists (n : N1.nat), C.equal N2.nat (f n) m := fun (m : N2.nat) => N2.nat_ind (fun m0 : N2.nat => exists n : N1.nat, C.equal N2.nat (f n) m0) (ex_intro (fun n : N1.nat => C.equal N2.nat (f n) N2.O) N1.O image_O) (fun (m0 : N2.nat) (Hm : exists n : N1.nat, C.equal N2.nat (f n) m0) => match Hm with | ex_intro _ x x0 => ex_intro (fun n : N1.nat => C.equal N2.nat (f n) (N2.S m0)) (N1.S x) (C.equal_leibniz N2.nat (N2.S (f x)) (f (N1.S x)) (C.equal_leibniz N2.nat (f (N1.S x)) (N2.S (f x)) (image_S x) (fun y : N2.nat => C.equal N2.nat y (f (N1.S x))) (C.equal_refl N2.nat (f (N1.S x)))) (fun n : N2.nat => C.equal N2.nat n (N2.S m0)) (C.equal_leibniz N2.nat (f x) m0 x0 (fun y : N2.nat => C.equal N2.nat (N2.S (f x)) (N2.S y)) (C.equal_refl N2.nat (N2.S (f x))))) end) m.
End Binnat_nat_make.

Module Coq_binnat_nat <: Nat_morphism Coq_connectives Coq_leibniz Coq_logic Coq_relations Coq_bool Coq_binnat Coq_nat := Binnat_nat_make Coq_connectives Coq_leibniz Coq_logic Coq_relations Coq_bool.

