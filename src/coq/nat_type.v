Require Import connectives_type.
Require Import leibniz_type.
Require Import logic_type.
Require Import relations_type.
Require Import bool_type.


Module Type Nat_Type (C : Connectives_Type) (L : Leibniz_Type) (G : Logic_Type C) (R : Relations_Type C G) (B : Bool_Type C L G R).
Parameter nat : Type.
Parameter O : nat.
Parameter S : nat -> nat.
Axiom match_nat_prop : forall (return_:(nat -> Prop)), (return_ O) -> (forall (n:nat), return_ (S n)) -> forall (z:nat), return_ z.
Parameter match_nat_type : forall (return_:Type), return_ -> (nat -> return_) -> nat -> return_.
Axiom axiom_match_nat_type_O : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), C.equal (return_type) (match_nat_type (return_type) case_O case_S O) case_O.
Definition eq_match_nat_type_O : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), L.leibniz (return_type) (match_nat_type (return_type) case_O case_S O) case_O := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:nat -> return_type) => ((((C.equal_leibniz) (return_type)) (match_nat_type (return_type) case_O case_S O)) (case_O)) ((((axiom_match_nat_type_O) (return_type)) (case_O)) (case_S)).
Definition sym_eq_match_nat_type_O : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), L.leibniz (return_type) case_O (match_nat_type (return_type) case_O case_S O) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:nat -> return_type) => ((((L.sym_leibniz) (return_type)) (match_nat_type (return_type) case_O case_S O)) (case_O)) ((((eq_match_nat_type_O) (return_type)) (case_O)) (case_S)).
Axiom axiom_match_nat_type_S : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), forall (n:nat), C.equal (return_type) (match_nat_type (return_type) case_O case_S (S n)) (case_S n).
Definition eq_match_nat_type_S : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), forall (n:nat), L.leibniz (return_type) (match_nat_type (return_type) case_O case_S (S n)) (case_S n) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:nat -> return_type) => fun (n:nat) => ((((C.equal_leibniz) (return_type)) (match_nat_type (return_type) case_O case_S (S n))) (case_S n)) (((((axiom_match_nat_type_S) (return_type)) (case_O)) (case_S)) (n)).
Definition sym_eq_match_nat_type_S : forall return_type, forall (case_O:return_type), forall (case_S:(nat -> return_type)), forall (n:nat), L.leibniz (return_type) (case_S n) (match_nat_type (return_type) case_O case_S (S n)) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:nat -> return_type) => fun (n:nat) => ((((L.sym_leibniz) (return_type)) (match_nat_type (return_type) case_O case_S (S n))) (case_S n)) (((((eq_match_nat_type_S) (return_type)) (case_O)) (case_S)) (n)).
Parameter filter_nat_type : forall (return_:Type), (nat -> return_) -> nat -> return_.
Axiom axiom_filter_nat_type_O : forall return_type, forall (return_:(nat -> return_type)), C.equal (return_type) (filter_nat_type (return_type) return_ O) (return_ O).
Definition eq_filter_nat_type_O : forall return_type, forall (return_:(nat -> return_type)), L.leibniz (return_type) (filter_nat_type (return_type) return_ O) (return_ O) := fun (return_type:Type) => fun (return_:nat -> return_type) => ((((C.equal_leibniz) (return_type)) (filter_nat_type (return_type) return_ O)) (return_ O)) (((axiom_filter_nat_type_O) (return_type)) (return_)).
Definition sym_eq_filter_nat_type_O : forall return_type, forall (return_:(nat -> return_type)), L.leibniz (return_type) (return_ O) (filter_nat_type (return_type) return_ O) := fun (return_type:Type) => fun (return_:nat -> return_type) => ((((L.sym_leibniz) (return_type)) (filter_nat_type (return_type) return_ O)) (return_ O)) (((eq_filter_nat_type_O) (return_type)) (return_)).
Axiom axiom_filter_nat_type_S : forall return_type, forall (return_:(nat -> return_type)), forall (n:nat), C.equal (return_type) (filter_nat_type (return_type) return_ (S n)) (return_ (S n)).
Definition eq_filter_nat_type_S : forall return_type, forall (return_:(nat -> return_type)), forall (n:nat), L.leibniz (return_type) (filter_nat_type (return_type) return_ (S n)) (return_ (S n)) := fun (return_type:Type) => fun (return_:nat -> return_type) => fun (n:nat) => ((((C.equal_leibniz) (return_type)) (filter_nat_type (return_type) return_ (S n))) (return_ (S n))) ((((axiom_filter_nat_type_S) (return_type)) (return_)) (n)).
Definition sym_eq_filter_nat_type_S : forall return_type, forall (return_:(nat -> return_type)), forall (n:nat), L.leibniz (return_type) (return_ (S n)) (filter_nat_type (return_type) return_ (S n)) := fun (return_type:Type) => fun (return_:nat -> return_type) => fun (n:nat) => ((((L.sym_leibniz) (return_type)) (filter_nat_type (return_type) return_ (S n))) (return_ (S n))) ((((eq_filter_nat_type_S) (return_type)) (return_)) (n)).
Axiom nat_ind : forall (Q:(nat -> Prop)), (Q O) -> (forall (x:nat), (Q x) -> Q (S x)) -> forall (x:nat), Q x.
Definition pred : nat -> nat := fun (n:nat) => match_nat_type (nat) O (fun (p:nat) => p) n.
Definition not_zero : nat -> Prop := fun (n:nat) => match_nat_type (Prop) C.False (fun (p:nat) => C.True) n.
Parameter le : nat -> nat -> Prop.
Axiom le_n : forall (n:nat), le n n.
Axiom le_S : forall (n:nat), forall (m:nat), (le n m) -> le n (S m).
Axiom le_ind : forall (n:nat), forall (Q:(nat -> Prop)), (Q n) -> (forall (m:nat), (le n m) -> (Q m) -> Q (S m)) -> forall (m:nat), (le n m) -> Q m.
Definition lt : nat -> nat -> Prop := fun (n:nat) => fun (m:nat) => le (S n) m.
Parameter plus : nat -> nat -> nat.
Parameter plus_body : nat -> nat -> nat.
Axiom axiom_plus : forall (n:nat), C.equal (nat -> nat) (plus n) (filter_nat_type (nat -> nat) plus_body n).
Definition eq_plus : forall (n:nat), L.leibniz (nat -> nat) (plus n) (filter_nat_type (nat -> nat) plus_body n) := fun (n:nat) => ((((C.equal_leibniz) (nat -> nat)) (plus n)) (filter_nat_type (nat -> nat) plus_body n)) ((axiom_plus) (n)).
Definition sym_eq_plus : forall (n:nat), L.leibniz (nat -> nat) (filter_nat_type (nat -> nat) plus_body n) (plus n) := fun (n:nat) => ((((L.sym_leibniz) (nat -> nat)) (plus n)) (filter_nat_type (nat -> nat) plus_body n)) ((eq_plus) (n)).
Axiom axiom_plus_body_O : C.equal (nat -> nat) (plus_body O) (fun (m:nat) => m).
Definition eq_plus_body_O : L.leibniz (nat -> nat) (plus_body O) (fun (m:nat) => m) := ((((C.equal_leibniz) (nat -> nat)) (plus_body O)) (fun (m:nat) => m)) (axiom_plus_body_O).
Definition sym_eq_plus_body_O : L.leibniz (nat -> nat) (fun (m:nat) => m) (plus_body O) := ((((L.sym_leibniz) (nat -> nat)) (plus_body O)) (fun (m:nat) => m)) (eq_plus_body_O).
Axiom axiom_plus_body_S : forall (n:nat), C.equal (nat -> nat) (plus_body (S n)) (fun (m:nat) => S (plus n m)).
Definition eq_plus_body_S : forall (n:nat), L.leibniz (nat -> nat) (plus_body (S n)) (fun (m:nat) => S (plus n m)) := fun (n:nat) => ((((C.equal_leibniz) (nat -> nat)) (plus_body (S n))) (fun (m:nat) => S (plus n m))) ((axiom_plus_body_S) (n)).
Definition sym_eq_plus_body_S : forall (n:nat), L.leibniz (nat -> nat) (fun (m:nat) => S (plus n m)) (plus_body (S n)) := fun (n:nat) => ((((L.sym_leibniz) (nat -> nat)) (plus_body (S n))) (fun (m:nat) => S (plus n m))) ((eq_plus_body_S) (n)).
Definition nat_case : forall (n:nat), forall (P:(nat -> Prop)), ((G.eq (nat) n O) -> P O) -> (forall (m:nat), (G.eq (nat) n (S m)) -> P (S m)) -> P n := fun (n:nat) => fun (P:nat -> Prop) => ((((nat_ind) (fun (_x_365:nat) => ((G.eq (nat) _x_365 O) -> P O) -> (forall (m:nat), (G.eq (nat) _x_365 (S m)) -> P (S m)) -> P _x_365)) (fun (auto:(G.eq (nat) O O) -> P O) => (fun (auto':forall (m:nat), (G.eq (nat) O (S m)) -> P (S m)) => ((auto) (((G.refl) (nat)) (O)))))) (fun (x_366:nat) => fun (_x_368:((G.eq (nat) x_366 O) -> P O) -> (forall (m:nat), (G.eq (nat) x_366 (S m)) -> P (S m)) -> P x_366) => (fun (auto:(G.eq (nat) (S x_366) O) -> P O) => (fun (auto':forall (m:nat), (G.eq (nat) (S x_366) (S m)) -> P (S m)) => (((auto') (x_366)) (((G.refl) (nat)) (S x_366))))))) (n).
Definition nat_elim2 : forall (R:(nat -> nat -> Prop)), (forall (n:nat), R O n) -> (forall (n:nat), R (S n) O) -> (forall (n:nat), forall (m:nat), (R n m) -> R (S n) (S m)) -> forall (n:nat), forall (m:nat), R n m := fun (R:nat -> nat -> Prop) => fun (ROn:forall (n:nat), R O n) => (fun (RSO:forall (n:nat), R (S n) O) => (fun (RSS:forall (n:nat), forall (m:nat), (R n m) -> R (S n) (S m)) => (fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => forall (m:nat), R _x_365 m)) (fun (m:nat) => (ROn) (m))) (fun (n0:nat) => fun (Rn0m:forall (m:nat), R n0 m) => (fun (m:nat) => ((((match_nat_prop) (fun (__:nat) => R (S n0) __)) ((RSO) (n0))) (fun (auto:nat) => (((RSS) (n0)) (auto)) ((Rn0m) (auto)))) (m)))) (n)))).
Definition pred_Sn : forall (n:nat), G.eq (nat) n (pred (S n)) := fun (n:nat) => ((((((sym_eq_match_nat_type_S) (nat)) (O)) (fun (p:nat) => p)) (n)) (fun (y:nat) => G.eq (nat) n y)) (((G.refl) (nat)) (n)).
Definition injective_S : R.injective (nat) (nat) S := fun (x:nat) => fun (y:nat) => fun (auto:G.eq (nat) (S x) (S y)) => (((((((G.rewrite_l) (nat)) (y)) (fun (__:nat) => G.eq (nat) __ y)) (((G.refl) (nat)) (y))) (x)) (((((((G.rewrite_r) (nat)) (pred (S x))) (fun (__:nat) => G.eq (nat) y __)) (((((((G.rewrite_r) (nat)) (S y)) (fun (__:nat) => G.eq (nat) y (pred __))) ((pred_Sn) (y))) (S x)) (auto))) (x)) ((pred_Sn) (x)))).
Definition plus_O_n : forall (n:nat), G.eq (nat) n (plus O n) := fun (n:nat) => (((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => G.eq (nat) n (y n))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => G.eq (nat) n (y n))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => G.eq (nat) n (y n))) (((G.refl) (nat)) (n)))).
Definition plus_n_O : forall (n:nat), G.eq (nat) n (plus n O) := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => G.eq (nat) _x_365 (plus _x_365 O))) ((((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => G.eq (nat) O (y O))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => G.eq (nat) O (y O))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => G.eq (nat) O (y O))) (((G.refl) (nat)) (O)))))) (fun (x_366:nat) => fun (_x_368:G.eq (nat) x_366 (plus x_366 O)) => ((((sym_eq_plus) (S x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S x_366) (y O))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S x_366) (y O))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S x_366) (y O))) (((((((G.rewrite_l) (nat)) (x_366)) (fun (__:nat) => G.eq (nat) (S x_366) (S __))) (((G.refl) (nat)) (S x_366))) (plus x_366 O)) (_x_368))))))) (n).
Definition plus_n_Sm : forall (n:nat), forall (m:nat), G.eq (nat) (S (plus n m)) (plus n (S m)) := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => forall (m:nat), G.eq (nat) (S (plus _x_365 m)) (plus _x_365 (S m)))) (fun (m:nat) => (((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus O (S m)))) ((((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => G.eq (nat) (S (filter_nat_type (nat -> nat) plus_body O m)) (y (S m)))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => G.eq (nat) (S (filter_nat_type (nat -> nat) plus_body O m)) (y (S m)))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus_body O (S m)))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus_body O (S m)))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => G.eq (nat) (S m) (y (S m)))) (((G.refl) (nat)) (S m))))))))) (fun (x_366:nat) => fun (_x_368:forall (m:nat), G.eq (nat) (S (plus x_366 m)) (plus x_366 (S m))) => (fun (m:nat) => (((sym_eq_plus) (S x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus (S x_366) (S m)))) ((((sym_eq_plus) (S x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (filter_nat_type (nat -> nat) plus_body (S x_366) m)) (y (S m)))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (filter_nat_type (nat -> nat) plus_body (S x_366) m)) (y (S m)))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus_body (S x_366) (S m)))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (y m)) (plus_body (S x_366) (S m)))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:(nat -> nat)) => G.eq (nat) (S (S (plus x_366 m))) (y (S m)))) (((((((G.rewrite_r) (nat)) (plus x_366 (S m))) (fun (__:nat) => G.eq (nat) (S __) (S (plus x_366 (S m))))) (((((((G.rewrite_r) (nat)) (plus x_366 (S (S m)))) (fun (__:nat) => G.eq (nat) __ (S (plus x_366 (S m))))) (((((((G.rewrite_r) (nat)) (plus x_366 (S (S m)))) (fun (__:nat) => G.eq (nat) (plus x_366 (S (S m))) __)) (((G.refl) (nat)) (plus x_366 (S (S m))))) (S (plus x_366 (S m)))) ((_x_368) (S m)))) (S (plus x_366 (S m)))) ((_x_368) (S m)))) (S (plus x_366 m))) ((_x_368) (m))))))))))) (n).
Definition commutative_plus : R.commutative (nat) plus := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => forall (y:nat), G.eq (nat) (plus _x_365 y) (plus y _x_365))) (fun (y:nat) => (((sym_eq_plus) (O)) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y O))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y O))) (((sym_eq_plus_body_O) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y O))) (((((((G.rewrite_l) (nat)) (y)) (fun (__:nat) => G.eq (nat) y __)) (((G.refl) (nat)) (y))) (plus y O)) ((plus_n_O) (y))))))) (fun (x_366:nat) => fun (_x_368:forall (y:nat), G.eq (nat) (plus x_366 y) (plus y x_366)) => (fun (y:nat) => (((sym_eq_plus) (S x_366)) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y (S x_366)))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y (S x_366)))) ((((sym_eq_plus_body_S) (x_366)) (fun (z:(nat -> nat)) => G.eq (nat) (z y) (plus y (S x_366)))) (((((((G.rewrite_r) (nat)) (plus x_366 (S y))) (fun (__:nat) => G.eq (nat) __ (plus y (S x_366)))) (((((((G.rewrite_r) (nat)) (plus y (S x_366))) (fun (__:nat) => G.eq (nat) __ (plus y (S x_366)))) (((G.refl) (nat)) (plus y (S x_366)))) (plus x_366 (S y))) (((((((G.rewrite_l) (nat)) (S (plus x_366 y))) (fun (__:nat) => G.eq (nat) __ (plus y (S x_366)))) (((((((G.rewrite_r) (nat)) (plus y x_366)) (fun (__:nat) => G.eq (nat) (S __) (plus y (S x_366)))) (((plus_n_Sm) (y)) (x_366))) (plus x_366 y)) ((_x_368) (y)))) (plus x_366 (S y))) (((plus_n_Sm) (x_366)) (y))))) (S (plus x_366 y))) (((plus_n_Sm) (x_366)) (y)))))))) (n).
Definition associative_plus : R.associative (nat) plus := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => forall (y:nat), forall (z:nat), G.eq (nat) (plus (plus _x_365 y) z) (plus _x_365 (plus y z)))) (fun (y:nat) => fun (z:nat) => (((sym_eq_plus) (O)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus O y) z) (x (plus y z)))) ((((sym_eq_plus) (O)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (filter_nat_type (nat -> nat) plus_body O (plus y z)))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (filter_nat_type (nat -> nat) plus_body O (plus y z)))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus_body O y) z) (x (plus y z)))) (((sym_eq_plus_body_O) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus_body O y) z) (x (plus y z)))) (((sym_eq_plus_body_O) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (plus y z))) (((G.refl) (nat)) (plus y z))))))))) (fun (x_366:nat) => fun (_x_368:forall (y:nat), forall (z:nat), G.eq (nat) (plus (plus x_366 y) z) (plus x_366 (plus y z))) => (fun (y:nat) => fun (z:nat) => (((sym_eq_plus) (S x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus (S x_366) y) z) (x (plus y z)))) ((((sym_eq_plus) (S x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (filter_nat_type (nat -> nat) plus_body (S x_366) (plus y z)))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (filter_nat_type (nat -> nat) plus_body (S x_366) (plus y z)))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus_body (S x_366) y) z) (x (plus y z)))) ((((sym_eq_plus_body_S) (x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (plus_body (S x_366) y) z) (x (plus y z)))) ((((sym_eq_plus_body_S) (x_366)) (fun (x:(nat -> nat)) => G.eq (nat) (plus (x y) z) (S (plus x_366 (plus y z))))) ((((sym_eq_plus) (S (plus x_366 y))) (fun (x:(nat -> nat)) => G.eq (nat) (x z) (S (plus x_366 (plus y z))))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (plus x_366 y)) (fun (x:(nat -> nat)) => G.eq (nat) (x z) (S (plus x_366 (plus y z))))) ((((sym_eq_plus_body_S) (plus x_366 y)) (fun (x:(nat -> nat)) => G.eq (nat) (x z) (S (plus x_366 (plus y z))))) (((((((G.rewrite_r) (nat)) (plus x_366 (plus y z))) (fun (__:nat) => G.eq (nat) (S __) (S (plus x_366 (plus y z))))) (((G.refl) (nat)) (S (plus x_366 (plus y z))))) (plus (plus x_366 y) z)) (((_x_368) (y)) (z)))))))))))))) (n).
Definition assoc_plus1 : forall (a:nat), forall (b:nat), forall (c:nat), G.eq (nat) (plus c (plus b a)) (plus (plus b c) a) := fun (a:nat) => fun (b:nat) => fun (c:nat) => ((((((G.rewrite_r) (nat)) (plus a b)) (fun (__:nat) => G.eq (nat) (plus c __) (plus (plus b c) a))) (((((((G.rewrite_r) (nat)) (plus a (plus b c))) (fun (__:nat) => G.eq (nat) (plus c (plus a b)) __)) (((((((G.rewrite_r) (nat)) (plus a (plus b c))) (fun (__:nat) => G.eq (nat) __ (plus a (plus b c)))) (((G.refl) (nat)) (plus a (plus b c)))) (plus c (plus a b))) (((((((G.rewrite_l) (nat)) (plus (plus a b) c)) (fun (__:nat) => G.eq (nat) (plus c (plus a b)) __)) (((commutative_plus) (c)) (plus a b))) (plus a (plus b c))) ((((associative_plus) (a)) (b)) (c))))) (plus (plus b c) a)) (((commutative_plus) (plus b c)) (a)))) (plus b a)) (((commutative_plus) (b)) (a)).
Definition injective_plus_r : forall (n:nat), R.injective (nat) (nat) (fun (m:nat) => plus n m) := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => R.injective (nat) (nat) (fun (m:nat) => plus _x_365 m))) ((((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) (fun (x:nat) => fun (y:nat) => fun (auto:G.eq (nat) x y) => (((((((G.rewrite_l) (nat)) (x)) (fun (__:nat) => G.eq (nat) x __)) (((G.refl) (nat)) (x))) (y)) (auto))))))) (fun (x_366:nat) => fun (_x_368:forall (x:nat), forall (y:nat), (G.eq (nat) (plus x_366 x) (plus x_366 y)) -> G.eq (nat) x y) => ((((sym_eq_plus) (S x_366)) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (x_366)) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:(nat -> nat)) => R.injective (nat) (nat) (fun (m:nat) => y m))) (fun (x:nat) => fun (y:nat) => fun (auto:G.eq (nat) (S (plus x_366 x)) (S (plus x_366 y))) => ((((_x_368) (x)) (y)) ((((injective_S) (plus x_366 x)) (plus x_366 y)) (((((((G.rewrite_r) (nat)) (plus x_366 (S x))) (fun (__:nat) => G.eq (nat) __ (S (plus x_366 y)))) (((((((G.rewrite_r) (nat)) (plus x_366 (S y))) (fun (__:nat) => G.eq (nat) (plus x_366 (S x)) __)) (((((((G.rewrite_l) (nat)) (plus x_366 (S x))) (fun (__:nat) => G.eq (nat) (plus x_366 (S x)) __)) (((G.refl) (nat)) (plus x_366 (S x)))) (plus x_366 (S y))) (((((((G.rewrite_l) (nat)) (S (plus x_366 y))) (fun (__:nat) => G.eq (nat) (plus x_366 (S x)) __)) (((((((G.rewrite_l) (nat)) (S (plus x_366 x))) (fun (__:nat) => G.eq (nat) __ (S (plus x_366 y)))) (auto)) (plus x_366 (S x))) (((plus_n_Sm) (x_366)) (x)))) (plus x_366 (S y))) (((plus_n_Sm) (x_366)) (y))))) (S (plus x_366 y))) (((plus_n_Sm) (x_366)) (y)))) (S (plus x_366 x))) (((plus_n_Sm) (x_366)) (x))))))))))) (n).
Definition not_eq_S : forall (n:nat), forall (m:nat), (C.Not (G.eq (nat) n m)) -> C.Not (G.eq (nat) (S n) (S m)) := fun (n:nat) => fun (m:nat) => fun (auto:C.Not (G.eq (nat) n m)) => (((((G.not_to_not) (G.eq (nat) (S n) (S m))) (G.eq (nat) n m)) (fun (auto':G.eq (nat) (S n) (S m)) => (((((((G.rewrite_l) (nat)) (m)) (fun (__:nat) => G.eq (nat) __ m)) (((G.refl) (nat)) (m))) (n)) (((((((G.rewrite_r) (nat)) (pred (S n))) (fun (__:nat) => G.eq (nat) m __)) (((((((G.rewrite_r) (nat)) (S m)) (fun (__:nat) => G.eq (nat) m (pred __))) ((pred_Sn) (m))) (S n)) (auto'))) (n)) ((pred_Sn) (n)))))) (auto)).
Definition not_eq_O_S : forall (n:nat), C.Not (G.eq (nat) O (S n)) := fun (n:nat) => ((C.nmk) (G.eq (nat) O (S n))) (fun (eqOS:G.eq (nat) O (S n)) => ((((((eq_match_nat_type_O) (Prop)) (C.False)) (fun (p:nat) => C.True)) (fun (y:Prop) => y)) (((((((G.eq_ind_r) (nat)) (S n)) (fun (x:nat) => not_zero x)) (((((((sym_eq_match_nat_type_S) (Prop)) (C.False)) (fun (p:nat) => C.True)) (n)) (fun (y:Prop) => y)) (C.I))) (O)) (eqOS)))).
Definition lt_to_not_zero : forall (n:nat), forall (m:nat), (lt n m) -> not_zero m := fun (n:nat) => fun (m:nat) => fun (Hlt:lt n m) => (((((((le_ind) (S n)) (fun (x_417:nat) => not_zero x_417)) (((((((sym_eq_match_nat_type_S) (Prop)) (C.False)) (fun (p:nat) => C.True)) (n)) (fun (y:Prop) => y)) (C.I))) (fun (m0:nat) => fun (_x_419:le (S n) m0) => (fun (_x_421:not_zero m0) => (((((((sym_eq_match_nat_type_S) (Prop)) (C.False)) (fun (p:nat) => C.True)) (m0)) (fun (y:Prop) => y)) (C.I))))) (m)) (Hlt)).
Definition le_S_S : forall (n:nat), forall (m:nat), (le n m) -> le (S n) (S m) := fun (n:nat) => fun (m:nat) => fun (lenm:le n m) => (((((((le_ind) (n)) (fun (x_417:nat) => le (S n) (S x_417))) ((le_n) (S n))) (fun (m0:nat) => fun (_x_419:le n m0) => (fun (_x_421:le (S n) (S m0)) => ((((le_S) (S n)) (S m0)) (_x_421))))) (m)) (lenm)).
Definition le_O_n : forall (n:nat), le O n := fun (n:nat) => ((((nat_ind) (le O)) ((le_n) (O))) (fun (x_366:nat) => fun (_x_368:le O x_366) => ((((le_S) (O)) (x_366)) (_x_368)))) (n).
Definition le_n_Sn : forall (n:nat), le n (S n) := fun (n:nat) => (((le_S) (n)) (n)) ((le_n) (n)).
Definition transitive_le : R.transitive (nat) le := fun (a:nat) => fun (b:nat) => fun (c:nat) => fun (leab:le a b) => (fun (lebc:le b c) => (((((((le_ind) (b)) (fun (x_417:nat) => le a x_417)) (leab)) (fun (m:nat) => fun (_x_419:le b m) => (fun (_x_421:le a m) => ((((le_S) (a)) (m)) (_x_421))))) (c)) (lebc))).
Definition le_pred_n : forall (n:nat), le (pred n) n := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => le (pred _x_365) _x_365)) ((((((eq_match_nat_type_O) (nat)) (O)) (fun (p:nat) => p)) (fun (y:nat) => le (match_nat_type (nat) O (fun (p:nat) => p) O) y)) ((le_n) (pred O)))) (fun (x_366:nat) => fun (_x_368:le (pred x_366) x_366) => (((((((eq_match_nat_type_S) (nat)) (O)) (fun (p:nat) => p)) (x_366)) (fun (y:nat) => le (pred (S x_366)) (S y))) ((le_n_Sn) (pred (S x_366)))))) (n).
Definition monotonic_pred : R.monotonic (nat) le pred := fun (n:nat) => fun (m:nat) => fun (lenm:le n m) => (((((((le_ind) (n)) (fun (x_417:nat) => le (pred n) (pred x_417))) ((le_n) (pred n))) (fun (m0:nat) => fun (_x_419:le n m0) => (fun (_x_421:le (pred n) (pred m0)) => ((((((transitive_le) (pred n)) (n)) (pred (S m0))) ((le_pred_n) (n))) (((((((sym_eq_match_nat_type_S) (nat)) (O)) (fun (p:nat) => p)) (m0)) (fun (y:nat) => le n y)) (_x_419)))))) (m)) (lenm)).
Definition monotonic_le_plus_r : forall (n:nat), R.monotonic (nat) le (fun (m:nat) => plus n m) := fun (n:nat) => fun (a:nat) => fun (b:nat) => ((((nat_ind) (fun (_x_365:nat) => (le a b) -> le (plus _x_365 a) (plus _x_365 b))) ((((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => (le a b) -> le (plus O a) (y b))) ((((sym_eq_plus) (O)) (fun (y:(nat -> nat)) => (le a b) -> le (y a) (filter_nat_type (nat -> nat) plus_body O b))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => (le a b) -> le (y a) (filter_nat_type (nat -> nat) plus_body O b))) (((((sym_eq_filter_nat_type_O) (nat -> nat)) (plus_body)) (fun (y:(nat -> nat)) => (le a b) -> le (plus_body O a) (y b))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => (le a b) -> le (plus_body O a) (y b))) (((sym_eq_plus_body_O) (fun (y:(nat -> nat)) => (le a b) -> le (y a) b)) (fun (auto:le a b) => (auto))))))))) (fun (m:nat) => fun (H:(le a b) -> le (plus m a) (plus m b)) => (fun (leab:le a b) => ((((sym_eq_plus) (S m)) (fun (y:(nat -> nat)) => le (plus (S m) a) (y b))) ((((sym_eq_plus) (S m)) (fun (y:(nat -> nat)) => le (y a) (filter_nat_type (nat -> nat) plus_body (S m) b))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (m)) (fun (y:(nat -> nat)) => le (y a) (filter_nat_type (nat -> nat) plus_body (S m) b))) ((((((sym_eq_filter_nat_type_S) (nat -> nat)) (plus_body)) (m)) (fun (y:(nat -> nat)) => le (plus_body (S m) a) (y b))) ((((sym_eq_plus_body_S) (m)) (fun (y:(nat -> nat)) => le (plus_body (S m) a) (y b))) ((((sym_eq_plus_body_S) (m)) (fun (y:(nat -> nat)) => le (y a) (S (plus m b)))) ((((le_S_S) (plus m a)) (plus m b)) ((H) (leab)))))))))))) (n).
Definition monotonic_le_plus_l : forall (m:nat), R.monotonic (nat) le (fun (n:nat) => plus n m) := fun (m:nat) => fun (x:nat) => fun (y:nat) => fun (auto:le x y) => (((((G.eq_coerc) (le (plus m x) (plus m y))) (le (plus x m) (plus y m))) (((((monotonic_le_plus_r) (m)) (x)) (y)) (auto))) (((((((G.rewrite_r) (nat)) (plus m x)) (fun (__:nat) => G.eq (Prop) (le (plus m x) (plus m y)) (le __ (plus y m)))) (((((((G.rewrite_r) (nat)) (plus m y)) (fun (__:nat) => G.eq (Prop) (le (plus m x) (plus m y)) (le (plus m x) __))) (((G.refl) (Prop)) (le (plus m x) (plus m y)))) (plus y m)) (((commutative_plus) (y)) (m)))) (plus x m)) (((commutative_plus) (x)) (m)))).
Definition le_plus : forall (n1:nat), forall (n2:nat), forall (m1:nat), forall (m2:nat), (le n1 n2) -> (le m1 m2) -> le (plus n1 m1) (plus n2 m2) := fun (n1:nat) => fun (n2:nat) => fun (m1:nat) => fun (m2:nat) => fun (len:le n1 n2) => (fun (lem:le m1 m2) => ((((((transitive_le) (plus n1 m1)) (plus n1 m2)) (plus n2 m2)) (((((monotonic_le_plus_r) (n1)) (m1)) (m2)) (lem))) (((((monotonic_le_plus_l) (m2)) (n1)) (n2)) (len)))).
Definition le_plus_n : forall (n:nat), forall (m:nat), le m (plus n m) := fun (n:nat) => fun (m:nat) => ((((G.eq_coerc) (le (plus O m) (plus n m))) (le m (plus n m))) (((((monotonic_le_plus_l) (m)) (O)) (n)) ((le_O_n) (n)))) (((((((G.rewrite_l) (nat)) (m)) (fun (__:nat) => G.eq (Prop) (le __ (plus n m)) (le m (plus n m)))) (((G.refl) (Prop)) (le m (plus n m)))) (plus O m)) ((plus_O_n) (m))).
Definition le_plus_n_r : forall (n:nat), forall (m:nat), le m (plus m n) := fun (n:nat) => fun (m:nat) => ((((G.eq_coerc) (le m (plus n m))) (le m (plus m n))) (((le_plus_n) (n)) (m))) (((((((G.rewrite_r) (nat)) (plus n m)) (fun (__:nat) => G.eq (Prop) (le m (plus n m)) (le m __))) (((G.refl) (Prop)) (le m (plus n m)))) (plus m n)) (((commutative_plus) (m)) (n))).
Definition transitive_lt : R.transitive (nat) lt := fun (a:nat) => fun (b:nat) => fun (c:nat) => fun (ltab:lt a b) => (fun (ltbc:lt b c) => (((((((le_ind) (S b)) (fun (x_417:nat) => lt a x_417)) ((((le_S) (S a)) (b)) (ltab))) (fun (m:nat) => fun (_x_419:le (S b) m) => (fun (_x_421:lt a m) => ((((le_S) (S a)) (m)) (_x_421))))) (c)) (ltbc))).
Definition lt_to_le_to_lt : forall (n:nat), forall (m:nat), forall (p:nat), (lt n m) -> (le m p) -> lt n p := fun (n:nat) => fun (m:nat) => fun (p:nat) => fun (H:lt n m) => (fun (H1:le m p) => (((((((le_ind) (m)) (fun (x_417:nat) => lt n x_417)) (H)) (fun (m0:nat) => fun (_x_419:le m m0) => (fun (_x_421:lt n m0) => ((((((transitive_lt) (n)) (m0)) (S m0)) (_x_421)) (((((G.eq_coerc) (le (S m0) (plus O (S m0)))) (le (S m0) (S m0))) (((le_plus_n) (O)) (S m0))) (((((((G.rewrite_l) (nat)) (S m0)) (fun (__:nat) => G.eq (Prop) (le (S m0) __) (le (S m0) (S m0)))) (((G.refl) (Prop)) (le (S m0) (S m0)))) (plus O (S m0))) ((plus_O_n) (S m0)))))))) (p)) (H1))).
Definition le_to_lt_to_lt : forall (n:nat), forall (m:nat), forall (p:nat), (le n m) -> (lt m p) -> lt n p := fun (n:nat) => fun (m:nat) => fun (p:nat) => fun (H:le n m) => (((((((le_ind) (n)) (fun (x_417:nat) => (lt x_417 p) -> lt n p)) (fun (auto:lt n p) => (auto))) (fun (m0:nat) => fun (_x_419:le n m0) => (fun (_x_421:(lt m0 p) -> lt n p) => (fun (auto:lt (S m0) p) => ((_x_421) ((((((transitive_lt) (m0)) (S m0)) (p)) (((((G.eq_coerc) (le (S m0) (plus O (S m0)))) (le (S m0) (S m0))) (((le_plus_n) (O)) (S m0))) (((((((G.rewrite_l) (nat)) (S m0)) (fun (__:nat) => G.eq (Prop) (le (S m0) __) (le (S m0) (S m0)))) (((G.refl) (Prop)) (le (S m0) (S m0)))) (plus O (S m0))) ((plus_O_n) (S m0))))) (auto))))))) (m)) (H)).
Definition ltn_to_ltO : forall (n:nat), forall (m:nat), (lt n m) -> lt O m := fun (n:nat) => fun (m:nat) => fun (auto:lt n m) => ((((((lt_to_le_to_lt) (O)) (S n)) (m)) (((((G.eq_coerc) (le (S O) (plus n (S O)))) (le (S O) (S n))) (((le_plus_n) (n)) (S O))) (((((((G.rewrite_l) (nat)) (S n)) (fun (__:nat) => G.eq (Prop) (le (S O) __) (le (S O) (S n)))) (((G.refl) (Prop)) (le (S O) (S n)))) (plus n (S O))) (((((((G.rewrite_r) (nat)) (plus n O)) (fun (__:nat) => G.eq (nat) (S __) (plus n (S O)))) (((plus_n_Sm) (n)) (O))) (n)) ((plus_n_O) (n)))))) (auto)).
Definition lt_O_S : forall (n:nat), lt O (S n) := fun (n:nat) => (((ltn_to_ltO) (n)) (S n)) (((((G.eq_coerc) (le (S n) (plus O (S n)))) (le (S n) (S n))) (((le_plus_n) (O)) (S n))) (((((((G.rewrite_l) (nat)) (S n)) (fun (__:nat) => G.eq (Prop) (le (S n) __) (le (S n) (S n)))) (((G.refl) (Prop)) (le (S n) (S n)))) (plus O (S n))) ((plus_O_n) (S n)))).
Definition monotonic_lt_plus_r : forall (n:nat), R.monotonic (nat) lt (fun (m:nat) => plus n m) := fun (n:nat) => fun (x:nat) => fun (y:nat) => fun (auto:lt x y) => (((((G.eq_coerc) (le (plus n (S x)) (plus n y))) (le (S (plus n x)) (plus n y))) (((((monotonic_le_plus_r) (n)) (S x)) (y)) (auto))) (((((((G.rewrite_r) (nat)) (plus n (S x))) (fun (__:nat) => G.eq (Prop) (le (plus n (S x)) (plus n y)) (le __ (plus n y)))) (((G.refl) (Prop)) (le (plus n (S x)) (plus n y)))) (S (plus n x))) (((plus_n_Sm) (n)) (x)))).
Definition not_le_Sn_O : forall (n:nat), C.Not (le (S n) O) := fun (n:nat) => ((C.nmk) (le (S n) O)) (fun (Hlen0:le (S n) O) => ((((((eq_match_nat_type_O) (Prop)) (C.False)) (fun (p:nat) => C.True)) (fun (y:Prop) => y)) ((((lt_to_not_zero) (n)) (O)) (Hlen0)))).
Definition not_le_to_not_le_S_S : forall (n:nat), forall (m:nat), (C.Not (le n m)) -> C.Not (le (S n) (S m)) := fun (n:nat) => fun (m:nat) => fun (auto:C.Not (le n m)) => (((((G.not_to_not) (le (S n) (S m))) (le n m)) (fun (auto':le (S n) (S m)) => (((((G.eq_coerc) (le (pred (S n)) (pred (S m)))) (le n m)) ((((monotonic_pred) (S n)) (S m)) (auto'))) (((((((G.rewrite_l) (nat)) (n)) (fun (__:nat) => G.eq (Prop) (le __ (pred (S m))) (le n m))) (((((((G.rewrite_l) (nat)) (m)) (fun (__:nat) => G.eq (Prop) (le n __) (le n m))) (((G.refl) (Prop)) (le n m))) (pred (S m))) ((pred_Sn) (m)))) (pred (S n))) ((pred_Sn) (n)))))) (auto)).
Definition not_le_S_S_to_not_le : forall (n:nat), forall (m:nat), (C.Not (le (S n) (S m))) -> C.Not (le n m) := fun (n:nat) => fun (m:nat) => fun (auto:C.Not (le (S n) (S m))) => (((((G.not_to_not) (le n m)) (le (S n) (S m))) (fun (auto':le n m) => ((((le_S_S) (n)) (m)) (auto')))) (auto)).
Definition not_le_Sn_n : forall (n:nat), C.Not (le (S n) n) := fun (n:nat) => ((((nat_ind) (fun (_x_365:nat) => C.Not (le (S _x_365) _x_365))) ((not_le_Sn_O) (O))) (fun (x_366:nat) => fun (_x_368:C.Not (le (S x_366) x_366)) => ((((not_le_to_not_le_S_S) (S x_366)) (x_366)) (_x_368)))) (n).
Definition not_le_to_lt : forall (n:nat), forall (m:nat), (C.Not (le n m)) -> lt m n := ((((nat_elim2) (fun (__:nat) => fun (_0:nat) => (C.Not (le __ _0)) -> lt _0 __)) (fun (n:nat) => fun (abs:C.Not (le O n)) => (((C.falsity) (lt n O)) ((((G.absurd) (le O n)) (((((G.eq_coerc) (le O (plus n O))) (le O n)) (((le_plus_n) (n)) (O))) (((((((G.rewrite_l) (nat)) (n)) (fun (__:nat) => G.eq (Prop) (le O __) (le O n))) (((G.refl) (Prop)) (le O n))) (plus n O)) ((plus_n_O) (n))))) (abs))))) (fun (n:nat) => fun (auto:C.Not (le (S n) O)) => ((lt_O_S) (n)))) (fun (n:nat) => fun (m:nat) => fun (Hind:(C.Not (le n m)) -> lt m n) => (fun (HnotleSS:C.Not (le (S n) (S m))) => ((((le_S_S) (S m)) (n)) ((Hind) ((((not_le_S_S_to_not_le) (n)) (m)) (HnotleSS)))))).
Definition le_to_or_lt_eq : forall (n:nat), forall (m:nat), (le n m) -> C.Or (lt n m) (G.eq (nat) n m) := fun (n:nat) => fun (m:nat) => fun (lenm:le n m) => (((((((le_ind) (n)) (fun (x_417:nat) => C.Or (lt n x_417) (G.eq (nat) n x_417))) ((((R.RC_reflexive) (nat)) (lt)) (n))) (fun (m0:nat) => fun (_x_419:le n m0) => (fun (_x_421:C.Or (lt n m0) (G.eq (nat) n m0)) => ((((C.or_introl) (lt n (S m0))) (G.eq (nat) n (S m0))) ((((((le_to_lt_to_lt) (n)) (m0)) (S m0)) (_x_419)) (((((G.eq_coerc) (le (S m0) (plus O (S m0)))) (le (S m0) (S m0))) (((le_plus_n) (O)) (S m0))) (((((((G.rewrite_l) (nat)) (S m0)) (fun (__:nat) => G.eq (Prop) (le (S m0) __) (le (S m0) (S m0)))) (((G.refl) (Prop)) (le (S m0) (S m0)))) (plus O (S m0))) ((plus_O_n) (S m0))))))))) (m)) (lenm)).
Definition le_n_O_elim : forall (n:nat), (le n O) -> forall (P:(nat -> Prop)), (P O) -> P n := fun (n:nat) => ((((match_nat_prop) (fun (__:nat) => (le __ O) -> forall (P:(nat -> Prop)), (P O) -> P __)) (fun (auto:le O O) => (fun (P:nat -> Prop) => fun (auto':P O) => (auto')))) (fun (a:nat) => fun (abs:le (S a) O) => (((C.falsity) (forall (P:(nat -> Prop)), (P O) -> P (S a))) ((((G.absurd) (le (S a) O)) (abs)) ((not_le_Sn_O) (a)))))) (n).
Parameter eqb : nat -> nat -> B.bool.
Parameter eqb_body : nat -> nat -> B.bool.
Axiom axiom_eqb : forall (n:nat), C.equal (nat -> B.bool) (eqb n) (filter_nat_type (nat -> B.bool) eqb_body n).
Definition eq_eqb : forall (n:nat), L.leibniz (nat -> B.bool) (eqb n) (filter_nat_type (nat -> B.bool) eqb_body n) := fun (n:nat) => ((((C.equal_leibniz) (nat -> B.bool)) (eqb n)) (filter_nat_type (nat -> B.bool) eqb_body n)) ((axiom_eqb) (n)).
Definition sym_eq_eqb : forall (n:nat), L.leibniz (nat -> B.bool) (filter_nat_type (nat -> B.bool) eqb_body n) (eqb n) := fun (n:nat) => ((((L.sym_leibniz) (nat -> B.bool)) (eqb n)) (filter_nat_type (nat -> B.bool) eqb_body n)) ((eq_eqb) (n)).
Axiom axiom_eqb_body_O : C.equal (nat -> B.bool) (eqb_body O) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m).
Definition eq_eqb_body_O : L.leibniz (nat -> B.bool) (eqb_body O) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m) := ((((C.equal_leibniz) (nat -> B.bool)) (eqb_body O)) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m)) (axiom_eqb_body_O).
Definition sym_eq_eqb_body_O : L.leibniz (nat -> B.bool) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m) (eqb_body O) := ((((L.sym_leibniz) (nat -> B.bool)) (eqb_body O)) (fun (m:nat) => match_nat_type (B.bool) B.true (fun (q:nat) => B.false) m)) (eq_eqb_body_O).
Axiom axiom_eqb_body_S : forall (n:nat), C.equal (nat -> B.bool) (eqb_body (S n)) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m).
Definition eq_eqb_body_S : forall (n:nat), L.leibniz (nat -> B.bool) (eqb_body (S n)) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m) := fun (n:nat) => ((((C.equal_leibniz) (nat -> B.bool)) (eqb_body (S n))) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m)) ((axiom_eqb_body_S) (n)).
Definition sym_eq_eqb_body_S : forall (n:nat), L.leibniz (nat -> B.bool) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m) (eqb_body (S n)) := fun (n:nat) => ((((L.sym_leibniz) (nat -> B.bool)) (eqb_body (S n))) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => eqb n q) m)) ((eq_eqb_body_S) (n)).
Definition eqb_elim : forall (n:nat), forall (m:nat), forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m) := ((((nat_elim2) (fun (__:nat) => fun (_0:nat) => forall (P:(B.bool -> Prop)), ((G.eq (nat) __ _0) -> P B.true) -> ((C.Not (G.eq (nat) __ _0)) -> P B.false) -> P (eqb __ _0))) (fun (n:nat) => ((((match_nat_prop) (fun (__:nat) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O __) -> P B.true) -> ((C.Not (G.eq (nat) O __)) -> P B.false) -> P (eqb O __))) ((((sym_eq_eqb) (O)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O O) -> P B.true) -> ((C.Not (G.eq (nat) O O)) -> P B.false) -> P (y O))) (((((sym_eq_filter_nat_type_O) (nat -> B.bool)) (eqb_body)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O O) -> P B.true) -> ((C.Not (G.eq (nat) O O)) -> P B.false) -> P (y O))) (((sym_eq_eqb_body_O) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O O) -> P B.true) -> ((C.Not (G.eq (nat) O O)) -> P B.false) -> P (y O))) ((((((sym_eq_match_nat_type_O) (B.bool)) (B.true)) (fun (q:nat) => B.false)) (fun (y:B.bool) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O O) -> P B.true) -> ((C.Not (G.eq (nat) O O)) -> P B.false) -> P y)) (fun (P:B.bool -> Prop) => fun (auto:(G.eq (nat) O O) -> P B.true) => (fun (auto':(C.Not (G.eq (nat) O O)) -> P B.false) => ((auto) (((G.refl) (nat)) (O)))))))))) (fun (auto:nat) => (((sym_eq_eqb) (O)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O (S auto)) -> P B.true) -> ((C.Not (G.eq (nat) O (S auto))) -> P B.false) -> P (y (S auto)))) (((((sym_eq_filter_nat_type_O) (nat -> B.bool)) (eqb_body)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O (S auto)) -> P B.true) -> ((C.Not (G.eq (nat) O (S auto))) -> P B.false) -> P (y (S auto)))) (((sym_eq_eqb_body_O) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O (S auto)) -> P B.true) -> ((C.Not (G.eq (nat) O (S auto))) -> P B.false) -> P (y (S auto)))) (((((((sym_eq_match_nat_type_S) (B.bool)) (B.true)) (fun (q:nat) => B.false)) (auto)) (fun (y:B.bool) => forall (P:(B.bool -> Prop)), ((G.eq (nat) O (S auto)) -> P B.true) -> ((C.Not (G.eq (nat) O (S auto))) -> P B.false) -> P y)) (fun (P:B.bool -> Prop) => fun (auto':(G.eq (nat) O (S auto)) -> P B.true) => (fun (auto'':(C.Not (G.eq (nat) O (S auto))) -> P B.false) => ((auto'') ((not_eq_O_S) (auto)))))))))) (n))) (fun (n:nat) => (((sym_eq_eqb) (S n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) O) -> P B.true) -> ((C.Not (G.eq (nat) (S n) O)) -> P B.false) -> P (y O))) ((((((sym_eq_filter_nat_type_S) (nat -> B.bool)) (eqb_body)) (n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) O) -> P B.true) -> ((C.Not (G.eq (nat) (S n) O)) -> P B.false) -> P (y O))) ((((sym_eq_eqb_body_S) (n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) O) -> P B.true) -> ((C.Not (G.eq (nat) (S n) O)) -> P B.false) -> P (y O))) ((((((sym_eq_match_nat_type_O) (B.bool)) (B.false)) (fun (q:nat) => eqb n q)) (fun (y:B.bool) => forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) O) -> P B.true) -> ((C.Not (G.eq (nat) (S n) O)) -> P B.false) -> P y)) (fun (P:B.bool -> Prop) => fun (auto:(G.eq (nat) (S n) O) -> P B.true) => (fun (auto':(C.Not (G.eq (nat) (S n) O)) -> P B.false) => ((auto') (((((G.sym_not_eq) (nat)) (O)) (S n)) ((not_eq_O_S) (n))))))))))) (fun (n:nat) => fun (m:nat) => (((sym_eq_eqb) (S n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m)) -> forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) (S m)) -> P B.true) -> ((C.Not (G.eq (nat) (S n) (S m))) -> P B.false) -> P (y (S m)))) ((((((sym_eq_filter_nat_type_S) (nat -> B.bool)) (eqb_body)) (n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m)) -> forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) (S m)) -> P B.true) -> ((C.Not (G.eq (nat) (S n) (S m))) -> P B.false) -> P (y (S m)))) ((((sym_eq_eqb_body_S) (n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m)) -> forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) (S m)) -> P B.true) -> ((C.Not (G.eq (nat) (S n) (S m))) -> P B.false) -> P (y (S m)))) (((((((sym_eq_match_nat_type_S) (B.bool)) (B.false)) (fun (q:nat) => eqb n q)) (m)) (fun (y:B.bool) => (forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m)) -> forall (P:(B.bool -> Prop)), ((G.eq (nat) (S n) (S m)) -> P B.true) -> ((C.Not (G.eq (nat) (S n) (S m))) -> P B.false) -> P y)) (fun (auto:forall (P:(B.bool -> Prop)), ((G.eq (nat) n m) -> P B.true) -> ((C.Not (G.eq (nat) n m)) -> P B.false) -> P (eqb n m)) => (fun (P:B.bool -> Prop) => fun (auto':(G.eq (nat) (S n) (S m)) -> P B.true) => (fun (auto'':(C.Not (G.eq (nat) (S n) (S m))) -> P B.false) => ((((auto) (P)) (fun (auto''':G.eq (nat) n m) => ((auto') (((((((G.rewrite_l) (nat)) (n)) (fun (__:nat) => G.eq (nat) (S n) (S __))) (((G.refl) (nat)) (S n))) (m)) (auto'''))))) (fun (auto''':C.Not (G.eq (nat) n m)) => ((auto'') ((((not_eq_S) (n)) (m)) (auto''')))))))))))).
Definition eqb_false_to_not_eq : forall (n:nat), forall (m:nat), (G.eq (B.bool) (eqb n m) B.false) -> C.Not (G.eq (nat) n m) := fun (n:nat) => fun (m:nat) => (((((eqb_elim) (n)) (m)) (fun (__:B.bool) => (G.eq (B.bool) __ B.false) -> C.Not (G.eq (nat) n m))) (fun (auto:G.eq (nat) n m) => (fun (auto':G.eq (B.bool) B.true B.false) => (((((G.not_to_not) (G.eq (nat) n m)) (G.eq (B.bool) B.true B.false)) (fun (auto'':G.eq (nat) n m) => (((((((G.rewrite_l) (B.bool)) (B.true)) (fun (__:B.bool) => G.eq (B.bool) B.true __)) (((G.refl) (B.bool)) (B.true))) (B.false)) (auto')))) (B.not_eq_true_false))))) (fun (auto:C.Not (G.eq (nat) n m)) => (fun (auto':G.eq (B.bool) B.false B.false) => (auto))).
Parameter leb : nat -> nat -> B.bool.
Parameter leb_body : nat -> nat -> B.bool.
Axiom axiom_leb : forall (n:nat), C.equal (nat -> B.bool) (leb n) (filter_nat_type (nat -> B.bool) leb_body n).
Definition eq_leb : forall (n:nat), L.leibniz (nat -> B.bool) (leb n) (filter_nat_type (nat -> B.bool) leb_body n) := fun (n:nat) => ((((C.equal_leibniz) (nat -> B.bool)) (leb n)) (filter_nat_type (nat -> B.bool) leb_body n)) ((axiom_leb) (n)).
Definition sym_eq_leb : forall (n:nat), L.leibniz (nat -> B.bool) (filter_nat_type (nat -> B.bool) leb_body n) (leb n) := fun (n:nat) => ((((L.sym_leibniz) (nat -> B.bool)) (leb n)) (filter_nat_type (nat -> B.bool) leb_body n)) ((eq_leb) (n)).
Axiom axiom_leb_body_O : C.equal (nat -> B.bool) (leb_body O) (fun (m:nat) => B.true).
Definition eq_leb_body_O : L.leibniz (nat -> B.bool) (leb_body O) (fun (m:nat) => B.true) := ((((C.equal_leibniz) (nat -> B.bool)) (leb_body O)) (fun (m:nat) => B.true)) (axiom_leb_body_O).
Definition sym_eq_leb_body_O : L.leibniz (nat -> B.bool) (fun (m:nat) => B.true) (leb_body O) := ((((L.sym_leibniz) (nat -> B.bool)) (leb_body O)) (fun (m:nat) => B.true)) (eq_leb_body_O).
Axiom axiom_leb_body_S : forall (n:nat), C.equal (nat -> B.bool) (leb_body (S n)) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m).
Definition eq_leb_body_S : forall (n:nat), L.leibniz (nat -> B.bool) (leb_body (S n)) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m) := fun (n:nat) => ((((C.equal_leibniz) (nat -> B.bool)) (leb_body (S n))) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m)) ((axiom_leb_body_S) (n)).
Definition sym_eq_leb_body_S : forall (n:nat), L.leibniz (nat -> B.bool) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m) (leb_body (S n)) := fun (n:nat) => ((((L.sym_leibniz) (nat -> B.bool)) (leb_body (S n))) (fun (m:nat) => match_nat_type (B.bool) B.false (fun (q:nat) => leb n q) m)) ((eq_leb_body_S) (n)).
Definition leb_elim : forall (n:nat), forall (m:nat), forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m) := ((((nat_elim2) (fun (__:nat) => fun (_0:nat) => forall (P:(B.bool -> Prop)), ((le __ _0) -> P B.true) -> ((C.Not (le __ _0)) -> P B.false) -> P (leb __ _0))) (fun (n:nat) => (((sym_eq_leb) (O)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le O n) -> P B.true) -> ((C.Not (le O n)) -> P B.false) -> P (y n))) (((((sym_eq_filter_nat_type_O) (nat -> B.bool)) (leb_body)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le O n) -> P B.true) -> ((C.Not (le O n)) -> P B.false) -> P (y n))) (((sym_eq_leb_body_O) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le O n) -> P B.true) -> ((C.Not (le O n)) -> P B.false) -> P (y n))) (fun (P:B.bool -> Prop) => fun (auto:(le O n) -> P B.true) => (fun (auto':(C.Not (le O n)) -> P B.false) => ((auto) ((le_O_n) (n))))))))) (fun (n:nat) => (((sym_eq_leb) (S n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le (S n) O) -> P B.true) -> ((C.Not (le (S n) O)) -> P B.false) -> P (y O))) ((((((sym_eq_filter_nat_type_S) (nat -> B.bool)) (leb_body)) (n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le (S n) O) -> P B.true) -> ((C.Not (le (S n) O)) -> P B.false) -> P (y O))) ((((sym_eq_leb_body_S) (n)) (fun (y:(nat -> B.bool)) => forall (P:(B.bool -> Prop)), ((le (S n) O) -> P B.true) -> ((C.Not (le (S n) O)) -> P B.false) -> P (y O))) ((((((sym_eq_match_nat_type_O) (B.bool)) (B.false)) (fun (q:nat) => leb n q)) (fun (y:B.bool) => forall (P:(B.bool -> Prop)), ((le (S n) O) -> P B.true) -> ((C.Not (le (S n) O)) -> P B.false) -> P y)) (fun (P:B.bool -> Prop) => fun (auto:(le (S n) O) -> P B.true) => (fun (auto':(C.Not (le (S n) O)) -> P B.false) => ((auto') ((not_le_Sn_O) (n)))))))))) (fun (n:nat) => fun (m:nat) => (((sym_eq_leb) (S n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m)) -> forall (P:(B.bool -> Prop)), ((le (S n) (S m)) -> P B.true) -> ((C.Not (le (S n) (S m))) -> P B.false) -> P (y (S m)))) ((((((sym_eq_filter_nat_type_S) (nat -> B.bool)) (leb_body)) (n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m)) -> forall (P:(B.bool -> Prop)), ((le (S n) (S m)) -> P B.true) -> ((C.Not (le (S n) (S m))) -> P B.false) -> P (y (S m)))) ((((sym_eq_leb_body_S) (n)) (fun (y:(nat -> B.bool)) => (forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m)) -> forall (P:(B.bool -> Prop)), ((le (S n) (S m)) -> P B.true) -> ((C.Not (le (S n) (S m))) -> P B.false) -> P (y (S m)))) (((((((sym_eq_match_nat_type_S) (B.bool)) (B.false)) (fun (q:nat) => leb n q)) (m)) (fun (y:B.bool) => (forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m)) -> forall (P:(B.bool -> Prop)), ((le (S n) (S m)) -> P B.true) -> ((C.Not (le (S n) (S m))) -> P B.false) -> P y)) (fun (Hind:forall (P:(B.bool -> Prop)), ((le n m) -> P B.true) -> ((C.Not (le n m)) -> P B.false) -> P (leb n m)) => (fun (P:B.bool -> Prop) => fun (Pt:(le (S n) (S m)) -> P B.true) => (fun (Pf:(C.Not (le (S n) (S m))) -> P B.false) => ((((Hind) (P)) (fun (lenm:le n m) => ((Pt) ((((le_S_S) (n)) (m)) (lenm))))) (fun (nlenm:C.Not (le n m)) => ((Pf) ((((not_le_to_not_le_S_S) (n)) (m)) (nlenm)))))))))))).
End Nat_Type.